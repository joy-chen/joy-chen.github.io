<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joy</title>
  <subtitle>abc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joyflyaway.com/"/>
  <updated>2017-12-29T10:02:19.000Z</updated>
  <id>http://joyflyaway.com/</id>
  
  <author>
    <name>Joy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MTK_OTA分析</title>
    <link href="http://joyflyaway.com/2017/12/28/MTK-OTA%E5%88%86%E6%9E%90/"/>
    <id>http://joyflyaway.com/2017/12/28/MTK-OTA分析/</id>
    <published>2017-12-28T12:44:24.000Z</published>
    <updated>2017-12-29T10:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<h3 id="SystemUpdate"><a href="#SystemUpdate" class="headerlink" title="SystemUpdate"></a>SystemUpdate</h3><p>MainEntry<br>  onStart()<br>    bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE);<br>      onServiceConnected()<br>        queryPackagesInternal();<br>          mService.queryPackages();<br>            sQueryNewVersionThread.start();<br>              mHttpManager.queryNewVersion();<br>                checkNewVersion()</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;h3 id=&quot;SystemUpdate&quot;&gt;&lt;a href=&quot;#SystemUpdate&quot; class=&quot;headerlink&quot; title=&quot;SystemUpdate&quot;&gt;&lt;/a&gt;SystemUpdate&lt;/h3&gt;&lt;p&gt;MainEntry&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查看调用栈</title>
    <link href="http://joyflyaway.com/2017/12/28/%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <id>http://joyflyaway.com/2017/12/28/查看调用栈/</id>
    <published>2017-12-28T12:18:14.000Z</published>
    <updated>2017-12-29T10:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<ol>
<li>Java中打印调用栈<br>比较简单，利用Throwable，直接log中打印出来：<br>Log.d(TAG, Log.getStackTraceString(new Throwable()));   </li>
</ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;ol&gt;
&lt;li&gt;Java中打印调用栈&lt;br&gt;比较简单，利用Throwable，直接log中打印出来：&lt;br&gt;Log.d(TAG, Log.getStackTraceString(new Throwable()));   &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rk3288_OTA</title>
    <link href="http://joyflyaway.com/2017/12/25/rk3288-OTA/"/>
    <id>http://joyflyaway.com/2017/12/25/rk3288-OTA/</id>
    <published>2017-12-25T11:56:32.000Z</published>
    <updated>2017-12-29T10:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>OTA整个功能代码分布：服务端，recovery，framework层，以及apk共同组成<br>  APK(vendor/rockchip/common/apps/RKUpdateService)<br>  RK只提供apk，没有源码。反编译，apk的主要功能是从服务器下载ota包到本地，<br>  然后写入参数提供给recovery，然后重启进入recovery。</p>
<p>系统升级分为OTA升级和固件包升级<br>OTA方式：<br>1)写如下字段到/cache/recovery/last_flag<br>updating$path=/mnt/internal_sd/update.zip<br>2)写如下字段到/cache/recovery/command<br>–update_package=/mnt/internal_sd/update.zip<br>–locale=en_US<br>3)在adb shell中运行reboot recovery</p>
<h3 id="固件包方式："><a href="#固件包方式：" class="headerlink" title="固件包方式："></a>固件包方式：</h3><p>1)写如下字段到/cache/recovery/last_flag<br>updating$path=/mnt/internal_sd/update.img<br>2)写如下字段到/cache/recovery/command<br>–update_rkimage=/mnt/internal_sd/update.img<br>–locale=en_US<br>3)在adb shell中运行reboot recovery</p>
<h3 id="OTA升级失败排查"><a href="#OTA升级失败排查" class="headerlink" title="OTA升级失败排查:"></a>OTA升级失败排查:</h3><p><a href="http://blog.csdn.net/luzhenrong45/article/details/62042400" target="_blank" rel="external">http://blog.csdn.net/luzhenrong45/article/details/62042400</a></p>
<h3 id="dd命令："><a href="#dd命令：" class="headerlink" title="dd命令："></a>dd命令：</h3><p>  dd备份分区：<br>    df查看各分区使用<br>    mount查看挂载路径<br>    ls /dev/block／platform/xxx/ 查看各分区<br>    cat proc/partitions 查看各分区大小<br>  备份system分区：<br>  dd if=/dev/block/platform/ff0f0000.rksdmmc/by-name/system of=/sdcard/system.img<br>  挂载：mount -t ext4 system.img dest_path<br>  <a href="http://blog.csdn.net/u014134180/article/details/78120143" target="_blank" rel="external">http://blog.csdn.net/u014134180/article/details/78120143</a></p>
<h3 id="recovery相关部分的代码路径"><a href="#recovery相关部分的代码路径" class="headerlink" title="recovery相关部分的代码路径"></a>recovery相关部分的代码路径</h3><p>  ${code_root}/bootable/recovery<br>  ${code_root}/bootable/recovery/recovery.cpp<br>  ${code_root}/bootable/recovery/rkimage.cpp<br>  ${code_root}/frameworks/base/core/java/android/os/RecoverySystem.java</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>The recovery tool communicates with the main system through /cache files.<br>/cache/recovery/command - INPUT - command line for tool, one arg per line<br>/cache/recovery/log - OUTPUT - combined log file from recovery run(s)<br>/cache/recovery/intent - OUTPUT - intent that was passed in</p>
<p>The arguments which may be supplied in the recovery.command file:   </p>
<ul>
<li>–send_intent=anystring - write the text out to recovery.intent</li>
<li>–update_package=path - verify install an OTA package file</li>
<li>–wipe_data - erase user data (and cache), then reboot</li>
<li>–wipe_cache - wipe cache (but not user data), then reboot</li>
<li>–set_encrypted_filesystem=on|off - enables / diasables encrypted fs</li>
<li>–just_exit - do nothing; exit and reboot<br>Arguments may also be supplied in the bootloader control block (BCB).</li>
</ul>
<p>After completing, we remove /cache/recovery/command and reboot.</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>app执行安装/重置/清楚缓存操作调用代码文件<br>  frameworks/base/core/java/android/os/RecoverySystem.java<br>    installPackage<br>    rebootWipeUserData<br>    rebootWipeCache</p>
<p>上面的所有操作都是往/cache/recovery/command文件中写入不同的命令，在进入recovery后（recovery.cpp）对command的关键字进行判断，执行相应的操作</p>
<p>recovery.cpp<br>  -main()<br>   -&gt;install_package()<br>    install.cpp<br>      -&gt;install_package()<br>        -&gt;try_update_binary()</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;OTA整个功能代码分布：服务端，recovery，framework层，以及apk共同组成&lt;br&gt;  APK(vendor/rockchip/common/apps/RKUpdateService)&lt;br&gt;  RK只提供apk，没有源码。反
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rk3288源码结构</title>
    <link href="http://joyflyaway.com/2017/12/25/rk3288%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://joyflyaway.com/2017/12/25/rk3288源码结构/</id>
    <published>2017-12-25T09:11:54.000Z</published>
    <updated>2017-12-29T10:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>device/rockchip/rk3288：<br>板级配置<br>  device/rockchip/rk3288/rk3288.mk<br>    PRODUCT_NAME :=<br>    PRODUCT_BRAND :=<br>    PRODUCT_DEVICE :=<br>    PRODUCT_MODEL :=</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;device/rockchip/rk3288：&lt;br&gt;板级配置&lt;br&gt;  device/rockchip/rk3288/rk3288.mk&lt;br&gt;    PRODUCT_NAME :=&lt;br&gt;    PRODUCT_BRAND :=&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RK3288编译介绍</title>
    <link href="http://joyflyaway.com/2017/12/25/RK3288%E7%BC%96%E8%AF%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://joyflyaway.com/2017/12/25/RK3288编译介绍/</id>
    <published>2017-12-25T06:32:32.000Z</published>
    <updated>2017-12-29T10:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p><a href="http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux" target="_blank" rel="external">http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">upgrade_tool:RKTools/linux/Linux_Upgrade_Tool_v1.2/upgrade_tool</div></pre></td></tr></table></figure>
<p>烧写统一固件 update.img<br>sudo upgrade_tool uf update.img</p>
<p>烧写分区镜像：<br>sudo upgrade_tool di -b /path/to/boot.img<br>sudo upgrade_tool di -k /path/to/kernel.img<br>sudo upgrade_tool di -s /path/to/system.img<br>sudo upgrade_tool di -r /path/to/recovery.img<br>sudo upgrade_tool di -m /path/to/misc.img<br>sudo upgrade_tool di resource /path/to/resource.img<br>sudo upgrade_tool di -p paramater   #烧写 parameter<br>sudo upgrade_tool ul bootloader.bin # 烧写 bootloader</p>
<p>如果因 flash 问题导致升级时出错，可以尝试低级格式化、擦除 nand flash：<br>sudo upgrade_tool lf   # 低级格式化<br>sudo upgrade_tool ef   # 擦除</p>
<p>编译内核:<br>make -j${JOBS} -C kernel rockchip_defconfig<br>make -j${JOBS} -C kernel rk3288-${MODEL}.img</p>
<p>编译Android:<br>. build.sh<br>make -j8<br>./mkimage.sh</p>
<p>上一步骤的 ./mkimage.sh 会重新打包 boot.img 和 system.img, 并将其它相关的映像文件拷贝到目录 rockdev/Image-rk3288_box/ 中。以下列出一般固件用到的映像文件：<br>boot.img ：Android 的初始文件映像，负责初始化并加载 system 分区。<br>kernel.img ：内核映像。<br>misc.img ：misc 分区映像，负责启动模式切换和急救模式的参数传递。<br>recovery.img ：急救模式映像。<br>resource.img ：资源映像，内含开机图片和内核的设备树信息。<br>system.img ：Android 的 system 分区映像，ext4 文件系统格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wik
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://joyflyaway.com/2017/12/22/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://joyflyaway.com/2017/12/22/git常用命令/</id>
    <published>2017-12-22T09:03:01.000Z</published>
    <updated>2017-12-29T10:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>git checkout -b nativeBranchName remoteBranchPath 切换远程分支到本地<br>git diff –staged 查看未提交的更改</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;git checkout -b nativeBranchName remoteBranchPath 切换远程分支到本地&lt;br&gt;git diff –staged 查看未提交的更改&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Camera调试相关总结</title>
    <link href="http://joyflyaway.com/2017/12/21/camera/"/>
    <id>http://joyflyaway.com/2017/12/21/camera/</id>
    <published>2017-12-21T10:49:21.000Z</published>
    <updated>2017-12-29T10:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>1.获取设备的自然方向？<br>public int getDeviceDefaultOrientation() {<br>    WindowManager windowManager =  (WindowManager) getSystemService(Context.WINDOW_SERVICE);</p>
<pre><code>Configuration config = getResources().getConfiguration();
int rotation = windowManager.getDefaultDisplay().getRotation();

if ( ((rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180) &amp;&amp;
        config.orientation == Configuration.ORIENTATION_LANDSCAPE)
    || ((rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270) &amp;&amp;    
        config.orientation == Configuration.ORIENTATION_PORTRAIT)) {
  return Configuration.ORIENTATION_LANDSCAPE;
} else {
  return Configuration.ORIENTATION_PORTRAIT;
}
</code></pre><p>}</p>
<p>2.rk3288 摄像头显示改为前置？<br>cam_board.xml 里头有个front 和back配置<br><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=13091&amp;highlight=%C9%E3%CF%F1%CD%B7" target="_blank" rel="external">http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=13091&amp;highlight=%C9%E3%CF%F1%CD%B7</a></p>
<p>3.rk3288 摄像头向左翻转90%显示如何修改?<br><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=12667&amp;highlight=%C9%E3%CF%F1%CD%B7" target="_blank" rel="external">http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=12667&amp;highlight=%C9%E3%CF%F1%CD%B7</a></p>
<p>4.查看相机型号版本<br>getprop | grep sys_graphic</p>
<p>5.camera配置文件path<br>hardware/rk29/camera/Config</p>
<p>6.关键log点<br>CameraHal,</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;1.获取设备的自然方向？&lt;br&gt;public int getDeviceDefaultOrientation() {&lt;br&gt;    WindowManager windowManager =  (WindowManager) getSyst
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自定义view</title>
    <link href="http://joyflyaway.com/2017/10/30/%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    <id>http://joyflyaway.com/2017/10/30/自定义view/</id>
    <published>2017-10-30T04:30:35.000Z</published>
    <updated>2017-11-03T09:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>view<br>1.分析view需要哪些属性，在构造方法里获取处理。<br>2.重写测量方法<br>3.重写ondraw方法</p>
<p>viewgroup<br>1.测量<br>2.布局<br>3.事件处理 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;view&lt;br&gt;1.分析view需要哪些属性，在构造方法里获取处理。&lt;br&gt;2.重写测量方法&lt;br&gt;3.重写ondraw方法&lt;/p&gt;
&lt;p&gt;viewgroup&lt;br&gt;1.测量&lt;br&gt;2.布局&lt;br&gt;3.事件处理 &lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>睡眠后按键无法唤醒的问题，如何看唤醒过程的log来定位问题</title>
    <link href="http://joyflyaway.com/2017/04/26/%E4%BA%AE%E5%B1%8F%E8%BF%87%E7%A8%8B/"/>
    <id>http://joyflyaway.com/2017/04/26/亮屏过程/</id>
    <published>2017-04-26T08:32:40.000Z</published>
    <updated>2017-04-27T05:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>【使用说明】<br>(1)  以下是列出的整个按键唤醒的log关键点，每条都有粗体字说明其含义以及该注意的关键字；<br>(2)  红色的是kernel log，其他都是main log；<br>(3)  一条一条依次检查，直到如果发现某条log找不到，那问题就出在这个地方；<br>(4)  仅限于JB2之后的Android版本，JB2之前流程相对比较简单；    </p>
<p>kernel-Check Point【1】：按键中断<br> <5>[   78.721504] 1)[Power/PMIC] [pwrkey_int_handler] Press pwrkey</5></p>
<p>Check Point【2】：上层收到按键事件<br>01-09 03:37:40.102   513   561 D WindowManager: interceptKeyTq keycode=26</p>
<p>Check Point【3】：PMS的wakeUp被调用<br>01-09 03:37:40.171   513   531 D PowerManager_performance: wakeUpNoUpdateLocked: eventTime=78826</p>
<p>Check Point【4】：发出MSG_BROADCAST<br>01-09 03:37:40.171   513   531 D PowerManagerNotifier: onWakeUpStarted</p>
<p>Check Point【5】：发出第一个MSG_UPDATE_POWER_STATE<br>01-09 03:37:40.174   513   531 D PowerManagerDisplayController: sendMessage</p>
<p>Check Point【6】：收到并处理MSG_BROADCAST，并且状态是从2变到1<br>01-09 03:37:40.194   513   530 D PowerManagerNotifier: sendNextBroadcast, mBroadcastedPowerState=2, mActualPowerState=1  </p>
<p>Check Point【7】：开始绘制keyguard的流程，发出NOTIFY_SCREEN_ON，等windowToken<br>01-09 03:37:40.217   513   530 D KeyguardViewMediator: notifyScreenOnLocked</p>
<p>Check Point【8】：收到并处理NOTIFY_SCREEN_ON<br>01-09 03:37:40.224   513   531 D KeyguardViewMediator: handleNotifyScreenOn</p>
<p>Check Point【9】：完成绘制keyguard，拿到windowToken<br>01-09 03:37:40.370   513   531 I WindowManager: Lock screen displayed</p>
<p>Check Point【10】：调用回调函数mSceenOnListener，解除Screen on Blocker，mNestCount必须是0<br>01-09 03:37:40.371   513   531 D PowerManagerService: Screen on unblocked: mNestCount=0  </p>
<p>Check Point【11】：处理第一个MSG_UPDATE_POWER_STATE，这里会第一次scheduleScreenUpdate<br>01-09 03:37:40.254   513   546 D PowerManagerDisplayState: setScreenOn: on=true</p>
<p>Check Point【12】：第一次执行scheduleScreenUpdate，进入setState<br>01-09 03:37:40.330   513   546 D PowerManagerDisplayState: Requesting new screen state: on=true, backlight=0</p>
<p>Check Point【13】：发出第二个MSG_UPDATE_POWER_STATE<br>01-09 03:37:40.334   513   546 D PowerManagerDisplayController: sendMessage.  </p>
<p>Check Point【14】：第一次执行mTask， on跟onChanged 必须都是true<br>01-09 03:37:40.334   513   546 D PowerManagerDisplayState: mTask: on = true, onChanged = true, backlightChanged = false</p>
<p>kernel-Check Point【15】：进入unblankAllDisplays，开始底层late_resume流程<br>01-09 03:37:40.334   513   546 D PowerManagerService: unblankAllDisplays in …</p>
<p>Check Point【16】：底层late_resume流程结束<br>01-09 03:37:40.673   513   546 D PowerManagerService-JNI: Excessive delay in autosuspend_disable() while turning screen on: 337ms  </p>
<p>Check Point【17】：unblankAllDisplays流程结束<br>01-09 03:37:40.701   513   546 D PowerManager_performance: unblankAllDisplays out …  </p>
<p>Check Point【18】：处理第二个MSG_UPDATE_POWER_STATE<br>01-09 03:37:40.702   513   546 D PowerManagerDisplayController: setScreenOn true  </p>
<p>Check Point【19】：前面的Screen On Blocker被解除，才会调用这里<br>01-09 03:37:40.702   513   546 D PowerManagerDisplayController: Unblocked screen on after 447 ms  </p>
<p>Check Point【20】：设置ElectronBeamLevel，值不为0才能点亮背光，并且这里会第二次scheduleScreenUpdate<br>01-09 03:37:40.704   513   546 D PowerManagerDisplayState: setElectronBeamLevel: level=1.0  </p>
<p>Check Point【21】：第二次执行scheduleScreenUpdate，进入setState，注意backlight值不为0<br>01-09 03:37:40.718   513   546 D PowerManagerDisplayState: Requesting new screen state: on=true, backlight=86,  </p>
<p>Check Point【22】：第二次执行mTask，backlightChanged必须是true<br>01-09 03:37:40.721   513   546 D PowerManagerDisplayState: mTask: on = true, onChanged = false, backlightChanged = true</p>
<p>Check Point【23】：调用light service，写backlight节点，light 0表示backlight<br>01-09 03:37:40.721   513   546 D LightsService: setLight_native: light=0, colorARGB=0xff565656, flashMode=0,</p>
<p>kernel-Check Point【24】：驱动底层背光生效</p>
<p><4>[   79.447236] (1)[546:PowerManagerSer]mt65xx_leds_set_cust: set brightness, name:lcd-backlight, mode:6, level:86</4></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>待机时，怎么看AP每次wake up起来的时长</title>
    <link href="http://joyflyaway.com/2017/04/26/%E5%94%A4%E9%86%92%E6%97%B6%E9%95%BF/"/>
    <id>http://joyflyaway.com/2017/04/26/唤醒时长/</id>
    <published>2017-04-26T02:51:20.000Z</published>
    <updated>2017-04-26T08:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION]"></a>DESCRIPTION]</h3><p>分析待机平均电流高的问题时，经常需要知道每次wake up起来的时间点，以及唤醒的时长，以此找到一些异常的唤醒</p>
<h3 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="[SOLUTION]"></a>[SOLUTION]</h3><p>MT6572<br>（1）查找kernel log中的“Wakeup Succefully”信息<br>（2）“往下”查找离这条log最近的带“UTC”的log，UTC log中显示的时间就是唤醒的时间（跟main log的时间一致）<br>（3）往下查找离这条log最近的“[SPM] Kernel Suspend with”信息，跟“Wakeup Succefully”的时间戳相减就是wake up的时长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg：</div><div class="line">&lt;4&gt;[ 2497.698724]-(0)[789:kworker/u:3][PCM WAKEUP NORMAL]CPU WAKE UP BY: EINT :0x10000</div><div class="line">&lt;6&gt;[ 2497.901281] (0)[789:kworker/u:3]PM: suspend exit 2013-05-27 00:40:53.186864384 UTC</div><div class="line">&lt;2&gt;[ 2539.341088]-(0)[789:kworker/u:3][SPM] Kernel Suspend with cpu_pdn=1, infra_pdn=1</div><div class="line">唤醒时间点：00：40：53</div><div class="line">唤醒时长：2539-2497 = 42s</div></pre></td></tr></table></figure></p>
<p>其他平台<br>（1）查找kernel log中的“wake up by XXX”信息<br>（2）“往下”查找离这条log最近的带“UTC”的log，UTC log中显示的时间加8小时就是真实的唤醒时间（跟main log的时间一致）<br>（3）往下查找离这条log最近的“wakesrc”信息，跟“wake up by XXX”的时间戳相减就是wake up的时长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">eg：</div><div class="line">&lt;5&gt;[  621.286161] (0)[53:kworker/u:2][Power/Sleep] wake up by EINT (0x20)(0x4)(41695)</div><div class="line">&lt;5&gt;[  621.626419] (0)[310:WindowManagerPo][request_suspend_state]: wakeup (3-&gt;0) at 612863283411 (2013-05-24 07:50:14.331687541 UTC)</div><div class="line">&lt;5&gt;[  665.287105] (0)[1218:kworker/u:3][Power/Sleep] sec = 300, wakesrc = 0x1ec</div><div class="line"></div><div class="line">唤醒时间点：07(+8)：50：14 = 15：50：14</div><div class="line">唤醒时长：665-621 = 44s</div></pre></td></tr></table></figure></p>
<h2 id="待机电流问题，如何查找wakelock"><a href="#待机电流问题，如何查找wakelock" class="headerlink" title="待机电流问题，如何查找wakelock"></a>待机电流问题，如何查找wakelock</h2><p>【step1-找kernel层的wakelock】</p>
<p>（1）先搜索从wake进入sleep的过程中打印出来的当前处于活动状态的wakelock<br>关键字“print_active_wakeup_sources”，类似于下面这样的log：</p>
<p>  [print_active_wakeup_sources]: activity: PowerManagerService<br>  [print_active_wakeup_sources]: activity: syspb_149<br>  [print_active_wakeup_sources]: activity: EINT wakelock</p>
<p>如果没有这样的log，可以把所有申请wakelock的代码搜出来，关键字“ws activate-&gt;”</p>
<p>（2）然后往下搜索有没有这些wakelock释放的位置<br>关键字“ws deactivate-&gt;”类似如下log：</p>
<pre><code>ws deactivate-&gt;  PowerManagerService
ws deactivate-&gt;  EINT wakelock
</code></pre><p>（3）那会出项两种情况<br>a. 根本没有找到释放某个wakelock的log<br>那就可以确实是这个wakelock导致（比如上面的syspb_149）<br>b. 有找到释放的log，但是中间间隔时间很长<br>这个就要看时间戳了，所以把申请释放的时间戳相减就是真实的wakelock锁住的时长</p>
<p>（4）找到wakelock后，要做的就是去检查wakelock的使用者<br>          a. 如果发现出问题的不是PowerManagerService的wakelock，那么就直接找对应的驱动代码就行了<br>b. 如果是，就要继续看main log</p>
<p>【step2-找user层的wakelock】</p>
<p>（1）找到所有上层的wakelock申请的log<br>关键字“acquireWakeLockInternal”，会搜出来很多，类似下面的log：</p>
<p>acquireWakeLockInternal: lock=1131418552, flags=0x1, tag=”GSM”, ws=null, uid=1001, pid=696<br>acquireWakeLockInternal: lock=1131101696, flags=0x1, tag=”RILJ”, ws=null, uid=1001, pid=696<br>acquireWakeLockInternal: lock=1130767880, flags=0x20, tag=”PhoneGlobals”, ws=null, uid=1001, pid=696</p>
<p>但是不要担心，一般像 RILJ / ActivityManager / AlarmManager申请释放很频繁的就不用理会；flag的bit0不为1的也不用理会（bit0标识锁住底层不进sleep；但是有个例外，就是Psensor对应的wakelock，flags为0x20，在早期JB版本也会锁住底层）</p>
<p>（2）找到这些wakelock释放的log<br>关键字“releaseWakeLockInternal”，但是你可能只能看到下面这样的log：</p>
<p>releaseWakeLockInternal: lock=1131101696, flags=0x0<br>releaseWakeLockInternal: lock=1131418552, flags=0x0<br>releaseWakeLockInternal: lock=1130767880, flags=0x1(这个flag为1表示waitForNegativeProximity)</p>
<p>跟acquire的log的对应关系就是看lock=后面的整数值，就知道wakelock是在哪个时间点释放的了，两个时间戳相减就是锁住的时间，抓住wakelock时间不长的就可以忽略，找到那个长时间锁住的wakelock就是系统无法休眠的罪魁祸首</p>
<p>（3）找到wakelock后，就根据“tag”的字符串去找对应的代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ANR分析</title>
    <link href="http://joyflyaway.com/2017/04/21/ANR%E5%88%86%E6%9E%90/"/>
    <id>http://joyflyaway.com/2017/04/21/ANR分析/</id>
    <published>2017-04-21T08:50:37.000Z</published>
    <updated>2017-12-29T10:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>ANR分为一下几类：</p>
<ul>
<li>广播ANR</li>
<li>Service ANR</li>
<li>ContentProvider ANR</li>
<li>Input ANR</li>
<li>WatchDog</li>
</ul>
<p>产生ANR原因：   </p>
<ul>
<li>耗时操作</li>
<li>自身服务阻塞</li>
<li>系统阻塞</li>
<li>内存紧张</li>
<li>CPU资源抢占</li>
</ul>
<p>对于这些ANR，给大家的推荐一下大致分析思路和相关日志，通常发生ANR时，首先去查找对应Trace日志，看看主线程是否在处理该广播或被阻塞，如果发现上述现象，那么恭喜你，已经很接近答案了。但如果发现堆栈完全处于空闲状态，那么很不幸，就需要扩大参考面了，需要结合log日志进行分析，日志包括logcat, kernel日志，cpuinfo以及meminfo等，参考顺序从前向后。<br>1、分析logcat思路：首先在日志中搜索（“anr in”，“low_memory”, “slow_operation”）等关键字，通过该类关键字主要是查看系统Cpu负载，如果是发现应用进程CPU明显过高，那么很有可能是该进程抢占CPU过多导致，系统调度不及时,误认为应用发生了超时行为。<br>2、分析kernel思路：在此类日志中直接搜索lowmemorykiller, 如果存在则查看发生时间和ANR时间是否大致对应，相差无几的话，可以从该日志中看到操作系统层面当前内存情况，Free Memory说明的是空闲物理内存，File Free说明的则是文件Cache，也就是应用或系统从硬盘读取文件，使用结束后，kernel并没有这正释放这类内存，加以缓存，目的是为了下次读写过程加快速度。当然，发现Free和Other整体数值都偏低时，Kernel会进行一定程度的内存交换，导致整个系统卡顿。同时这类现象也会体现在log日志“slow_operation”中，即系统进程的调度也会收到影响。<br>3、分析cpuinfo思路：这类日志一目了然，可以清晰的看到哪类进程CPU偏高，如果存在明显偏高进程，那么ANR和此进程抢占CPU有一定关系。当然，如发现Kswapd，emmc进程在top中，则说明遇到系统内存压力或文件IO开销。<br>4、分析meminfo思路：分析该类日志，主要是看哪类应用或系统占用内存偏高，如果应用内存占用比较正常，系统也没有发生过度内存使用，那么则说明系统中缓存了大量进程，并没有及时释放导致系统整体内存偏低。   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App启动过程</title>
    <link href="http://joyflyaway.com/2017/04/19/App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://joyflyaway.com/2017/04/19/App启动过程/</id>
    <published>2017-04-19T08:02:01.000Z</published>
    <updated>2017-04-21T08:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h4 id="从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈"><a href="#从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈" class="headerlink" title="从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈"></a>从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈</h4><p>-&gt;com.android.launcher3.Launcher#onClick<br>&emsp;-&gt;Launcher#onClickAppShortcut<br>&emsp;&emsp;-&gt;Launcher#startAppShortcutOrInfoActivity<br>&emsp;&emsp;&emsp;-&gt;Launcher#startActivitySafely<br>&emsp;&emsp;&emsp;&emsp;-&gt;Launcher#startActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;Activity#startActivity</p>
<h4 id="从Activity-startActivity，到启动进程和launch-activity的调用堆栈"><a href="#从Activity-startActivity，到启动进程和launch-activity的调用堆栈" class="headerlink" title="从Activity#startActivity，到启动进程和launch activity的调用堆栈"></a>从Activity#startActivity，到启动进程和launch activity的调用堆栈</h4><p><code>1.调用堆栈</code><br><code>1-1.准备新的activity</code><br>-&gt;Activity#startActivity<br>&emsp;-&gt;Activity#startActivityForResult  //此时mInstrumentation变量为源activity的，即launcher3<br>&emsp;&emsp;-&gt;Instrumentation#execStartActivity<br>&emsp;&emsp;&emsp;-&gt;ActivityManagerService#startActivity<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#startActivityAsUser<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startActivityMayWait<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startActivityUncheckedLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#startActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#resumeTopActivitiesLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityInnerLocked  </p>
<p><code>1-2.暂停旧的activity</code><br>&emsp;-&gt;ActivityStackSupervisor#pauseBackStacks<br>&emsp;&emsp;-&gt;ActivityStack#startPausingLocked<br>&emsp;&emsp;&emsp;-&gt;ActivityThread#schedulePauseActivity<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#handlePauseActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#activityPaused<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#activityPausedLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#completePauseLocked   </p>
<p><code>1-3.启动进程</code><br>&emsp;-&gt;ActivityStackSupervisor#resumeTopActivitiesLocked<br>&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityLocked<br>&emsp;&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityInnerLocked<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startSpecificActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#startProcessLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;Process#start<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#main<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;从ActivityThread#attach<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#attachApplication<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#attachApplicationLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread$ApplicationThread#bindApplication<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#handleBindApplication    </p>
<p><code>1-4.启动新的activity，走ActivityStackSupervisor#attachApplicationLocked分支</code><br>&emsp;-&gt;ActivityManagerService#attachApplicationLocked<br>&emsp;&emsp;-&gt;ActivityStackSupervisor#attachApplicationLocked<br>&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#realStartActivityLocked<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread$ApplicationThread#scheduleLaunchActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#handleLaunchActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#performLaunchActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;LoadedApk#makeApplication<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;Activity#attach   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编译问题</title>
    <link href="http://joyflyaway.com/2017/04/19/%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"/>
    <id>http://joyflyaway.com/2017/04/19/编译问题/</id>
    <published>2017-04-19T02:15:43.000Z</published>
    <updated>2017-04-21T08:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="编译android-7-0-出现Try-increasing-heap-size-with-java-option-‘-Xmx‘错误解决方案"><a href="#编译android-7-0-出现Try-increasing-heap-size-with-java-option-‘-Xmx‘错误解决方案" class="headerlink" title="编译android 7.0 出现Try increasing heap size with java option ‘-Xmx‘错误解决方案"></a>编译android 7.0 出现Try increasing heap size with java option ‘-Xmx<size>‘错误解决方案</size></h3><p>出现这个错误是由于电脑内存不足，在命令行分别执行以下三条语句，然后继续编译<br>export JACK_SERVER_VM_ARGUMENTS=”-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g”<br>./prebuilts/sdk/tools/jack-admin kill-server<br>./prebuilts/sdk/tools/jack-admin start-server   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MAT工具</title>
    <link href="http://joyflyaway.com/2017/03/30/MAT%E5%B7%A5%E5%85%B7/"/>
    <id>http://joyflyaway.com/2017/03/30/MAT工具/</id>
    <published>2017-03-30T11:50:15.000Z</published>
    <updated>2017-04-19T02:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Shallow-Heap-Size"><a href="#Shallow-Heap-Size" class="headerlink" title="Shallow Heap Size:"></a>Shallow Heap Size:</h3><p>指对象自身所占用的内存大小，不包含其引用的对象所占的内存大小。<br>1、数组类型<br>数组元素对象所占内存的大小总和。<br>2、非数组类型<br>对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。   </p>
<h3 id="Retained-Heap-Size"><a href="#Retained-Heap-Size" class="headerlink" title="Retained Heap Size:"></a>Retained Heap Size:</h3><p>前对象大小+当前对象可直接或间接引用到的对象的大小总和。<br>(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。<br>不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage。</p>
<h3 id="Java的内存泄露的特点"><a href="#Java的内存泄露的特点" class="headerlink" title="Java的内存泄露的特点"></a>Java的内存泄露的特点</h3><ul>
<li>Java中的内存泄露主要特征：可达，无用</li>
<li>无用指的是创建了但是不再使用之后没有释放</li>
<li>能重用但是却创建了新的对象进行处理</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效代码</title>
    <link href="http://joyflyaway.com/2017/03/30/%E9%AB%98%E6%95%88%E4%BB%A3%E7%A0%81/"/>
    <id>http://joyflyaway.com/2017/03/30/高效代码/</id>
    <published>2017-03-30T03:17:02.000Z</published>
    <updated>2017-04-19T02:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>通常来说，高效的代码需要满足下面两个规则：</p>
<ul>
<li>不要做冗余的动作</li>
<li>如果能避免，尽量不要分配内存</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>电源管理</title>
    <link href="http://joyflyaway.com/2017/03/10/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>http://joyflyaway.com/2017/03/10/电源管理/</id>
    <published>2017-03-10T03:15:41.000Z</published>
    <updated>2017-04-19T02:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android includes the following battery life enhancements:</p>
<ul>
<li>App Standby. The platform can place unused applications in App Standby mode, temporarily restricting network access and deferring syncs and jobs for those applications.</li>
<li>Doze. The platform can enter a state of deep sleep (periodically resuming normal operations) if users have not actively used their device (screen off and stationary) for extended periods of time. Android 7.0 also enables Doze to trigger a lighter set of optimizations when users turn off the device screen yet continue to move around.</li>
<li>Exemptions. System apps and cloud messaging services preloaded on a device are typically exempted from App Standby and Doze by default (although app developers can intent their applications into this setting). Users can exempt applications via the Settings menu.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android includes the following battery life enhancements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App Standby. The platform can place unused applications in App Sta
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查看内存信息</title>
    <link href="http://joyflyaway.com/2017/03/09/%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/"/>
    <id>http://joyflyaway.com/2017/03/09/查看内存信息/</id>
    <published>2017-03-09T05:28:15.000Z</published>
    <updated>2017-04-26T02:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>除了free与vmstat之外，透过调阅<strong>/proc/meminfo</strong>的内容可以查阅进一步的统计信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">cat /proc/meminfo</div><div class="line">MemTotal:     12142744 kB</div><div class="line">MemFree:      10889316 kB</div><div class="line">Buffers:        391964 kB</div><div class="line">Cached:         522584 kB</div><div class="line">SwapCached:          0 kB</div><div class="line">Active:         407604 kB</div><div class="line">Inactive:       564460 kB</div><div class="line">HighTotal:           0 kB</div><div class="line">HighFree:            0 kB</div><div class="line">LowTotal:     12142744 kB</div><div class="line">LowFree:      10889316 kB</div><div class="line">SwapTotal:    20972816 kB</div><div class="line">SwapFree:     20972816 kB</div><div class="line">Dirty:             304 kB</div><div class="line">Writeback:           0 kB</div><div class="line">AnonPages:       57388 kB</div><div class="line">Mapped:          23556 kB</div><div class="line">Slab:           214100 kB</div><div class="line">PageTables:       7328 kB</div><div class="line">NFS_Unstable:        0 kB</div><div class="line">Bounce:              0 kB</div><div class="line">CommitLimit:  27044188 kB</div><div class="line">Committed_AS:   372876 kB</div><div class="line">VmallocTotal: 34359738367 kB</div><div class="line">VmallocUsed:    281368 kB</div><div class="line">VmallocChunk: 34359456975 kB</div><div class="line">HugePages_Total:     0</div><div class="line">HugePages_Free:      0</div><div class="line">HugePages_Rsvd:      0M</div><div class="line">Hugepagesize:     2048 kB</div></pre></td></tr></table></figure></p>
<p>他的输出内容非常的多，但你可以分成几块来看：高阶、低阶的与內存统计信息。<br>高阶信息，基本上就等同于是在free看到的那些内容：<br>MemTotal是系统中可用的內存总量，但其实是扣掉了一些被kernel所保留的一点点空间。<br>MemFree是HighFree与LowFree的加总。<br>Buffers是buffer所占用的空间。// block 设备cache<br>Cached是不包含SwapCached的cache空间。// file cache<br>比较低阶的信息有：<br>Active指的是那些最近或是经常被使用的page，而Inactive则是那些最近都没有被使用的page。当系统需要调用新的page空间时，会先从Inactive的部分下手，因为Active的部分比较有机会被再度使用。<br>HighTotal与HighFree代表的是user space所能使用的以及还剩馀多少的使用空间。<br>LowTotal与LowFree则是kernel space所能使用的以及还剩馀多少的使用空间。<br>SwapTotal与SwapFree指的是swap所能使用以及还剩馀多少空间。<br>Dirty指的是等待被写入disk的数据量。<br>Writeback则是正在被写入disk的数据量。<br>AnonPages为non-paged的空间。<br>Mapped为/dev设备所mapped的空间。<br>Slab是kernel所使用的buffer空间。<br>PageTables是page管理的index大小。<br>VmallocTotal是透过vmalloc（）可以调用的內存大小。<br>VmallocUsed是透过vmalloc（）所调用的內存大小。<br>VmallocChunk则是记录还剩多少连续的可调用的內存空间。</p>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><p><code>A buffer</code> is something that has yet to be  “written”   to disk.<br>A cache` is something that has been  “read”   from the disk and stored  for   later use.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android便捷命令</title>
    <link href="http://joyflyaway.com/2017/03/07/Android%E4%BE%BF%E6%8D%B7%E5%91%BD%E4%BB%A4/"/>
    <id>http://joyflyaway.com/2017/03/07/Android便捷命令/</id>
    <published>2017-03-07T08:20:18.000Z</published>
    <updated>2017-04-19T02:16:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="pm"><a href="#pm" class="headerlink" title="pm"></a>pm</h2><p>  pm list package列出安装再设备上的应用：</p>
<ul>
<li>不带任何选项：列出所有的应用的包名：<br>pm list package</li>
<li>-s:列出系统应用<br>pm list package -s</li>
<li>-3:列出第三方应用<br>pm list package -3</li>
<li>-f:列出应用包名及对应的apk名及存放位置<br>pm list package -f</li>
<li>-i:列出应用包名及其安装来源<br>pm list package -i<br>例如：package:com.zhihu.android installer=com.xiaomi.market  </li>
<li>参数组合使用，例如查找三方应用中知乎的包名、apk存放位置、安装来源：<br>pm list package -f -3 -i zhihu<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package:/data/app/com.zhihu.android-1.apk=com.zhihu.android  installer=com.xiaomi.market</div></pre></td></tr></table></figure>
</li>
</ul>
<p>pm list permissions -g -d<br><code>列出系统所有危险权限</code></p>
<p>pm path 列出对应包名的.apk位置：</p>
<ul>
<li>pm path com.tencent.mobileqq<br>package:/data/app/com.tencent.mobileqq-1.apk</li>
</ul>
<p>pm dump，后跟包名，列出指定应用的dump信息，里面有各种信息：</p>
<ul>
<li>pm dump com.tencent.mobileqq<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Packages:</div><div class="line">Package [com.tencent.mobileqq] (4397f810):</div><div class="line">userId=10091 gids=[3003, 3002, 3001, 1028, 1015]</div><div class="line">pkg=Package&#123;43851660 com.tencent.mobileqq&#125;</div><div class="line">codePath=/data/app/com.tencent.mobileqq-1.apk</div><div class="line">resourcePath=/data/app/com.tencent.mobileqq-1.apk</div><div class="line">nativeLibraryPath=/data/app-lib/com.tencent.mobileqq-1</div><div class="line">versionCode=242 targetSdk=9</div><div class="line">versionName=5.6.0</div><div class="line">applicationInfo=ApplicationInfo&#123;43842cc8 com.tencent.mobileqq&#125;</div><div class="line">flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ]</div><div class="line">dataDir=/data/data/com.tencent.mobileqq</div><div class="line">supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]</div><div class="line">usesOptionalLibraries:</div><div class="line">com.google.android.media.effects</div><div class="line">com.motorola.hardware.frontcamera</div><div class="line">timeStamp=2015-05-13 14:04:24</div><div class="line">firstInstallTime=2015-04-03 20:50:07</div><div class="line">lastUpdateTime=2015-05-13 14:05:02</div><div class="line">installerPackageName=com.xiaomi.market</div><div class="line">signatures=PackageSignatures&#123;4397f8d8 [43980488]&#125;</div><div class="line">permissionsFixed=true haveGids=true installStatus=1</div><div class="line">pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ]</div><div class="line">User 0:  installed=true blocked=false stopped=false notLaunched=false enabled=0</div><div class="line">grantedPermissions:</div><div class="line">android.permission.CHANGE_WIFI_MULTICAST_STATE</div><div class="line">com.tencent.qav.permission.broadcast</div><div class="line">com.tencent.photos.permission.DATA</div><div class="line">com.tencent.wifisdk.permission.disconnect</div></pre></td></tr></table></figure>
</li>
</ul>
<p>pm install，安装应用。目标apk存放与PC端，用adb install安装。目标apk存放于Android设备上，用pm install安装             </p>
<p>pm uninstall，卸载应用，同adb uninstall,后面跟的参数都是应用的包名</p>
<p>pm clear，清除应用数据</p>
<h2 id="am"><a href="#am" class="headerlink" title="am"></a>am</h2><p>am start，启动一个Activity，以启动系统相机应用为例：   </p>
<ul>
<li>启动相机：<br>am start -n com.android.camera/.Camera</li>
<li>先停止目标应用，再启动：<br>am start -S com.android.camera/.Camera</li>
<li><p>等待应用完成启动：<br>am start -W com.android.camera/.Camera</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]                           cmp=com.android.camera/.Camera &#125;</div><div class="line">   Status: ok</div><div class="line">   Activity: com.android.camera/.Camera</div><div class="line">   ThisTime: 500</div><div class="line">   TotalTime: 500</div><div class="line">   Complete</div></pre></td></tr></table></figure>
</li>
<li><p>启动默认C页：<br>am start -a android.intent.action.VIEW -d <a href="http://testerhome.com" target="_blank" rel="external">http://testerhome.com</a></p>
</li>
<li>启动拨号器拨打10086<br>am start -a android.intent.action.CALL -d tel:10086</li>
<li>am monitor，监控crash与ANR</li>
<li>am force-stop，后跟包名，结束应用</li>
<li>am startsevice，启动一个服务</li>
<li>am broadcast，发送一个广播   </li>
</ul>
<h2 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h2><p>monkey -p com.jared.performancetool -v 500<br><code>-p表示包名，-v表示反馈级别 500就是500个伪随机事件,若在压力测试中程序崩溃或者接收到任何失控异常，就会自动停止。</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android名词释义</title>
    <link href="http://joyflyaway.com/2017/03/07/Android%E5%90%8D%E8%AF%8D%E9%87%8A%E4%B9%89/"/>
    <id>http://joyflyaway.com/2017/03/07/Android名词释义/</id>
    <published>2017-03-07T03:19:14.000Z</published>
    <updated>2017-03-09T08:07:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<ul>
<li>provisioning(配置,服务开通)</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android双应用功能实现</title>
    <link href="http://joyflyaway.com/2017/03/02/Android%E5%8F%8C%E5%BA%94%E7%94%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>http://joyflyaway.com/2017/03/02/Android双应用功能实现/</id>
    <published>2017-03-02T02:58:33.000Z</published>
    <updated>2017-04-19T02:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><br>UserManager:<br>  createProfileForUser()创建轮廓用户<br>DeleteNonRequiredAppsTask:<br>  配置用户应用<br>DevicePolicyManager：<br>  setActiveAdmin();<br>  setProfileOwner();<br>IActivityManager:<br>  startUserInBackground()开启用户</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
