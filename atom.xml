<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joy</title>
  <subtitle>abc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joyflyaway.com/"/>
  <updated>2018-04-03T02:19:58.000Z</updated>
  <id>http://joyflyaway.com/</id>
  
  <author>
    <name>Joy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android之自定义控件</title>
    <link href="http://joyflyaway.com/2018/04/03/Android%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    <id>http://joyflyaway.com/2018/04/03/Android之自定义控件/</id>
    <published>2018-04-03T02:19:58.000Z</published>
    <updated>2018-04-03T02:19:58.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK-之音频驱动</title>
    <link href="http://joyflyaway.com/2018/03/10/MTK-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/"/>
    <id>http://joyflyaway.com/2018/03/10/MTK-音频驱动/</id>
    <published>2018-03-10T07:33:04.000Z</published>
    <updated>2018-04-03T02:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>kernel-3.10/arch/arm64/configs/tx6735_65c_xz_l1_defconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CONFIG_MT_SND_SOC_V3=y</div><div class="line">CONFIG_MTK_SPEAKER=y</div></pre></td></tr></table></figure></p>
<h3 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h3><p>kernel-3.10/sound/soc/mediatek/mt_soc_audio_v3/</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android性能优化之内存优化</title>
    <link href="http://joyflyaway.com/2018/03/02/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://joyflyaway.com/2018/03/02/Android性能优化之内存优化/</id>
    <published>2018-03-02T06:45:24.000Z</published>
    <updated>2018-03-22T12:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>对于Java来说，就是new出来的Object 放在Heap上无法被GC回收（内存中存在无法被回收的对象）</p>
<h3 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h3><ul>
<li>Android Studio 内存分析工具</li>
<li>MAT 内存分析工具</li>
<li>LeakCanary 分析</li>
</ul>
<h3 id="Android-OOM"><a href="#Android-OOM" class="headerlink" title="Android OOM"></a>Android OOM</h3><p>Android系统的每个进程都有一个最大内存限制，如果申请的内存资源超过这个限制，系统就会抛出OOM错误。</p>
<h4 id="避免方法"><a href="#避免方法" class="headerlink" title="避免方法"></a>避免方法</h4><ul>
<li><p>对内存的状态进行监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onTrimMemory(int level) &#123;</div><div class="line">    super.onTrimMemory(level);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>避免内存抖动<br>避免在循环调用的场景下，生成对象</p>
</li>
</ul>
<h3 id="代码注意点"><a href="#代码注意点" class="headerlink" title="代码注意点"></a>代码注意点</h3><ul>
<li><p>节制地使用Service<br>建议使用JobScheduler，而尽量避免使用持久性的Service。还有建议使用IntentService，它会在处理完交代给它的任务之后尽快结束自己。</p>
</li>
<li><p>使用优化过的集合<br>Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，以及LongSparseArray等，使用这些API可以让我们的程序更加高效。</p>
</li>
<li><p>移除消耗内存的库、缩减Apk的大小<br>查看Apk的大小，包括三方库和内嵌的资源，这些都会影响应用消耗的内存。通过减少冗余、非必须或大的组件、库、图片、资源、动画等，都可以改善应用的内存消耗。</p>
</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK之USB-OTG</title>
    <link href="http://joyflyaway.com/2018/03/02/MTK%E4%B9%8BUSB-OTG/"/>
    <id>http://joyflyaway.com/2018/03/02/MTK之USB-OTG/</id>
    <published>2018-03-02T06:12:10.000Z</published>
    <updated>2018-04-03T02:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h3><p>1.查看电路原理图，USB device功能正常的话，说明USB HUB部分没问题<br>2.查看供电是否正常，是否需要配置GPIO口</p>
<h3 id="USB-OTG-配置"><a href="#USB-OTG-配置" class="headerlink" title="USB OTG 配置"></a>USB OTG 配置</h3><p>kernel-3.10/arch/arm64/configs/tx6735_65c_xz_l1_defconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CONFIG_USB_MTK_OTG=y</div><div class="line">CONFIG_USB_MTK_HDRC_HCD=y</div></pre></td></tr></table></figure></p>
<p>kernel-3.10/tools/dct/<br>在dws中设定OTG VBUS对应的输出控制pin配置为GPIO模式，var name为GPIO_OTG_DRVVBUS_PIN。再设定USB ID默认模式为IDDIG，var name为GPIO_OTG_IDDIG_EINT_PIN(具体哪个引脚，以及是否需要配置其他引脚，需要参考电路原理图)</p>
<p>建立挂载目录<br>device/tangxun/tx6735_65c_xz_l1/init.project.rc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">on init</div><div class="line">    mkdir /mnt/media_rw/usbotg 0700 media_rw media_rw</div><div class="line">    mkdir /storage/usbotg 0700 root root</div><div class="line"></div><div class="line">    service fuse_usbotg /system/bin/sdcard -u 1023 -g 1023 -w 1023 -d /mnt/media_rw/usbotg /storage/usbotg</div><div class="line">        class late_start</div><div class="line">        disabled</div></pre></td></tr></table></figure></p>
<p>device/mediatek/mt6735/fstab.mt6735<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/devices/platform/mt_usb                auto      vfat      defaults        voldmanaged=usbotg:auto</div></pre></td></tr></table></figure></p>
<p>device/tangxun/tx6735_65c_xz_l1/overlay/frameworks/base/core/res/res/xml/storage_list.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;storage android:mountPoint=&quot;/storage/usbotg&quot;</div><div class="line">     android:storageDescription=&quot;@string/storage_external_usb&quot;</div><div class="line">     android:removable=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK之GPIO</title>
    <link href="http://joyflyaway.com/2018/02/26/MTK%E4%B9%8BGPIO/"/>
    <id>http://joyflyaway.com/2018/02/26/MTK之GPIO/</id>
    <published>2018-02-26T11:40:24.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>tools/dct/DrvGen.exe<br>drivers/misc/mediatek/mach/mt6735/tx6735_65c_xz_l1/dct/dct/codegen.dws<br>tools/dct/GPIO_YuSu.cmp</p>
<p>mt_set_gpio_mode(GPIO_LCM_PWR_EN, GPIO_MODE_00);<br>mt_set_gpio_dir(GPIO_LCM_PWR_EN, GPIO_DIR_OUT);<br>mt_set_gpio_out(GPIO_LCM_PWR_EN, GPIO_OUT_ONE);</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mt6735_xc6130_ov2718驱动移植调试</title>
    <link href="http://joyflyaway.com/2018/02/26/mt6735-xc6130-ov2718%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D%E8%B0%83%E8%AF%95/"/>
    <id>http://joyflyaway.com/2018/02/26/mt6735-xc6130-ov2718驱动移植调试/</id>
    <published>2018-02-26T03:13:35.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="驱动文件"><a href="#驱动文件" class="headerlink" title="驱动文件"></a>驱动文件</h3><p>ov2718_mipi_yuv_h (HAL)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">camera_info_ov2718_mipi_yuv.cpp  </div><div class="line">camera_info_ov2718_mipi_yuv.h  </div><div class="line">camera_sensor_para_ov2718_mipi_yuv.h  </div><div class="line">camera_tuning_para_ov2718_mipi_yuv.cpp  </div><div class="line">config.ftbl.ov2718_mipi_yuv.h</div></pre></td></tr></table></figure></p>
<p>ov2718_mipi_yuv_k (KERNEL)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ov2718mipiyuv_CameraCustomized.h</div><div class="line">ov2718mipiyuv_Camera_Sensor_para.h  </div><div class="line">ov2718mipiyuv_Sensor.c  </div><div class="line">ov2718mipiyuv_Sensor.</div></pre></td></tr></table></figure></p>
<h3 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h3><p>1.配置config<br>device/tangxun/tx6735_65c_xz_l1/ProjectConfig.mk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CUSTOM_HAL_IMGSENSOR = ov2718_mipi_yuv</div><div class="line">CUSTOM_HAL_MAIN_IMGSENSOR = ov2718_mipi_yuv</div><div class="line">CUSTOM_KERNEL_IMGSENSOR = ov2718_mipi_yuv</div><div class="line">CUSTOM_KERNEL_MAIN_IMGSENSOR = ov2718_mipi_yuv</div></pre></td></tr></table></figure></p>
<p>kernel-3.10/arch/arm64/configs/tx6735_65c_xz_l1_defconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CONFIG_CUSTOM_KERNEL_IMGSENSOR=&quot;ov2718_mipi_yuv&quot;</div></pre></td></tr></table></figure></p>
<p>2.拷贝驱动<br>ov2718_mipi_yuv_k -&gt; kernel-3.10/drivers/misc/mediatek/imgsensor/src/mt6735/ov2718_mipi_yuv<br>ov2718_mipi_yuv_h -&gt; vendor/mediatek/proprietary/custom/mt6735/hal/D1/imgsensor/ov2718_mipi_yuv<br>config.ftbl.ov2718_mipi_yuv.h -&gt; ./vendor/mediatek/proprietary/custom/tx6735_65c_xz_l1/hal/sendepfeature/ov2718_mipi_yuv</p>
<p>3.添加摄像头注册信息<br>vendor/mediatek/proprietary/custom/mt6735/hal/D1/imgsensor_src/sensorlist.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#if defined(OV2718_MIPI_YUV)</div><div class="line">    YUV_INFO(OV2718MIPI_SENSOR_ID, SENSOR_DRVNAME_OV2718_MIPI_YUV, NULL),</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>kernel-3.10/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define OV2718MIPI_SENSOR_ID                    0x2770</div><div class="line">#define SENSOR_DRVNAME_OV2718_MIPI_YUV          &quot;ov2718mipiyuv&quot;</div></pre></td></tr></table></figure></p>
<p>4.为系统提供调用的API<br>kernel-3.10/drivers/misc/mediatek/imgsensor/src/mt6735/kd_sensorlist.h</p>
<p>5.camera 上电和掉电<br>kernel-3.10/drivers/misc/mediatek/mach/mt6735/tx6735_65c_xz_l1/camera/camera/kd_camera_hw.c</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK之lcm架构</title>
    <link href="http://joyflyaway.com/2018/02/22/MTK%E4%B9%8Blcm%E6%9E%B6%E6%9E%84/"/>
    <id>http://joyflyaway.com/2018/02/22/MTK之lcm架构/</id>
    <published>2018-02-22T09:24:36.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>Linux kernel有一些总线，比如USB、I2C等。对于每一个总线都会有一些设备和驱动挂在上面。驱动服务于匹配的设备，使Linux正确的操作硬件设备。当一个设备或者驱动注册到特定的总线上的时候就会触发总线匹配函数，比如一个设备注册到了总线，所有的该总线的驱动都会被枚举，判断是不是可以服务于新添加的设备（一般通过name来匹配），反之亦然。<br>如果总线匹配成功，就会调用驱动的probe函数，检查指定的硬件确实存在，然后确定是否所需的资源都能够从系统申请。<br>事实上，设备或者驱动能够正确的合作，在probe之后，模块初始化顺序决定于probe的执行顺序，可以由BSP函数中注册设备的顺序控制。MT6572平台，L版本的BSP文件放在kernel/arch/arm/mach-mt6572/mt_devs.c,mt_board_init()函数控制着probe的顺序。<br>platform虚拟总线，关联在该总线的设备和驱动通过name来匹配。</p>
<h3 id="源码路径"><a href="#源码路径" class="headerlink" title="源码路径"></a>源码路径</h3><p>drivers/misc/mediatek/lcm/mt65xx_lcm_list.c<br>arch/arm64/configs/tx6735_65c_xz_l1_defconfig</p>
<p>arch/arm64/configs/tx6735_65c_xz_l1_defconfig<br>CUSTOM_KERNEL_LCM = xxx  //对应lcm目录驱动的子目录名<br>配置驱动</p>
<h3 id="drivers-misc-mediatek-mach-mt6735-mt-devs-c"><a href="#drivers-misc-mediatek-mach-mt6735-mt-devs-c" class="headerlink" title="drivers/misc/mediatek/mach/mt6735/mt_devs.c"></a>drivers/misc/mediatek/mach/mt6735/mt_devs.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__init int mt_board_init(void) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-videox-mt6735-mtkfb-c"><a href="#drivers-misc-mediatek-videox-mt6735-mtkfb-c" class="headerlink" title="./drivers/misc/mediatek/videox/mt6735/mtkfb.c"></a>./drivers/misc/mediatek/videox/mt6735/mtkfb.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">static struct fb_ops mtkfb_ops = &#123;</div><div class="line">    .owner          = THIS_MODULE,</div><div class="line">    .fb_open        = mtkfb_open,</div><div class="line">    .fb_release     = mtkfb_release,</div><div class="line">    .fb_setcolreg   = mtkfb_setcolreg,</div><div class="line">    .fb_pan_display = mtkfb_pan_display_proxy,</div><div class="line">    .fb_fillrect    = cfb_fillrect,</div><div class="line">    .fb_copyarea    = cfb_copyarea,</div><div class="line">    .fb_imageblit   = cfb_imageblit,</div><div class="line">    .fb_cursor      = mtkfb_soft_cursor,</div><div class="line">    .fb_check_var   = mtkfb_check_var,</div><div class="line">    .fb_set_par     = mtkfb_set_par,</div><div class="line">    .fb_ioctl       = mtkfb_ioctl,</div><div class="line">#ifdef CONFIG_COMPAT</div><div class="line">	.fb_compat_ioctl = mtkfb_compat_ioctl,</div><div class="line">#endif    </div><div class="line">#ifdef CONFIG_DMA_SHARED_BUFFER</div><div class="line">    .fb_dmabuf_export = mtkfb_dmabuf_export,</div><div class="line">#endif</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static struct platform_driver mtkfb_driver =</div><div class="line">&#123;</div><div class="line">    .driver = &#123;</div><div class="line">        .name    = MTKFB_DRIVER,</div><div class="line">#ifdef CONFIG_PM</div><div class="line">        .pm     = &amp;mtkfb_pm_ops,</div><div class="line">#endif</div><div class="line">        .bus     = &amp;platform_bus_type,</div><div class="line">        .probe   = mtkfb_probe,</div><div class="line">        .remove  = mtkfb_remove,</div><div class="line">        .suspend = mtkfb_suspend,</div><div class="line">        .resume  = mtkfb_resume,</div><div class="line">	.shutdown = mtkfb_shutdown,</div><div class="line">	.of_match_table = mtkfb_of_ids,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div><div class="line">static int mtkfb_probe(struct device *dev) ｛</div><div class="line">  primary_display_init(mtkfb_find_lcm_driver(), lcd_fps);</div><div class="line">  mtkfb_fbinfo_init(fbi);</div><div class="line">  mtkfb_register_sysfs(fbdev);</div><div class="line">  register_framebuffer(fbi);</div><div class="line">｝</div><div class="line">mtk_fb_probe函数主要做的工作如下：</div><div class="line">Called by LDM binding to probe andattach a new device.</div><div class="line"> * Initialization sequence:</div><div class="line"> *   1.allocate system fb_info structure</div><div class="line"> *     select panel type according to machine type</div><div class="line"> *   2.init LCD panel</div><div class="line"> *   3.init LCD controller and LCD DMA</div><div class="line"> *   4.init system fb_info structure</div><div class="line"> *   5.init gfx DMA</div><div class="line"> *   6.enable LCD panel</div><div class="line">       start LCD frame transfer</div><div class="line"> *   7.register system fb_info structure</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-videox-mt6735-primary-display-c"><a href="#drivers-misc-mediatek-videox-mt6735-primary-display-c" class="headerlink" title="./drivers/misc/mediatek/videox/mt6735/primary_display.c"></a>./drivers/misc/mediatek/videox/mt6735/primary_display.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int primary_display_init(char *lcm_name, unsigned int lcm_fps) &#123;</div><div class="line">  disp_lcm_probe( lcm_name, LCM_INTERFACE_NOTDEFINED);</div><div class="line">  disp_lcm_init(pgc-&gt;plcm, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-videox-mt6735-disp-lcm-c"><a href="#drivers-misc-mediatek-videox-mt6735-disp-lcm-c" class="headerlink" title="./drivers/misc/mediatek/videox/mt6735/disp_lcm.c"></a>./drivers/misc/mediatek/videox/mt6735/disp_lcm.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">disp_lcm_handle* disp_lcm_probe(char* plcm_name, LCM_INTERFACE_ID lcm_id)</div><div class="line">&#123;</div><div class="line">  lcm_drv = lcm_driver_list[0];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-lcm-mt65xx-lcm-list-c"><a href="#drivers-misc-mediatek-lcm-mt65xx-lcm-list-c" class="headerlink" title="drivers/misc/mediatek/lcm/mt65xx_lcm_list.c"></a>drivers/misc/mediatek/lcm/mt65xx_lcm_list.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">驱动列表</div><div class="line">LCM_DRIVER* lcm_driver_list[] = &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h3><ul>
<li><p>白屏无显示<br>检查电压是否正常，确定硬件是否有问题</p>
</li>
<li><p>黑色横条，颜色失真<br>初始化时序问题</p>
</li>
<li><p>闪屏<br>时序，pclk配置不对</p>
</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CAMERA_COMMON</title>
    <link href="http://joyflyaway.com/2018/02/09/CAMERA-COMMON/"/>
    <id>http://joyflyaway.com/2018/02/09/CAMERA-COMMON/</id>
    <published>2018-02-09T05:40:45.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="Image-Sensor类型"><a href="#Image-Sensor类型" class="headerlink" title="Image Sensor类型"></a>Image Sensor类型</h2><h3 id="YUV-Sensor"><a href="#YUV-Sensor" class="headerlink" title="YUV Sensor"></a>YUV Sensor</h3><p>YUV Sensor输出的Data格式为YUV，图像的效果处理使用Sensor内部的ISP，BB端接收YUV格式的data后只进行格式的转换，效果方面不进行处理，由于Sensor内部的ISP处理能力有限，且YUV Sensor的数据量比较大（YUV422的格式1个pixel2个byte），一般Size都比较小，常见的YUV sensor都是5M以下。</p>
<h3 id="Raw-Sensor"><a href="#Raw-Sensor" class="headerlink" title="Raw Sensor"></a>Raw Sensor</h3><p>Raw Sensor输出的Data格式为Raw，图像的效果处理使用BB端的ISP，BB端接收Raw data后进行一系列的图像处理（OB，Shading，AWB，Gamma，EE，ANR等），效果方面由BB端控制，需要针对不同的模组进行效果调试，Raw sensor是目前的主流，数据量比YUV Sensor小（RAW10 格式的sensor 1个pixel 10个bit）使用平台ISP处理，能支持较大的size。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK_CAMERA</title>
    <link href="http://joyflyaway.com/2018/02/09/MTK-CAMERA/"/>
    <id>http://joyflyaway.com/2018/02/09/MTK-CAMERA/</id>
    <published>2018-02-09T02:54:09.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="驱动配置"><a href="#驱动配置" class="headerlink" title="驱动配置"></a>驱动配置</h3><p>CONFIG_CUSTOM_KERNEL_LCM</p>
<h3 id="isp驱动"><a href="#isp驱动" class="headerlink" title="isp驱动"></a>isp驱动</h3><p>vendor/mediatek/proprietary/platform/mt6735/hardware/mtkcam/</p>
<h3 id="摄像头驱动"><a href="#摄像头驱动" class="headerlink" title="摄像头驱动"></a>摄像头驱动</h3><p>kernel-3.10/drivers/misc/mediatek/imgsensor/src/mt6735/</p>
<h3 id="驱动结构添加"><a href="#驱动结构添加" class="headerlink" title="驱动结构添加"></a>驱动结构添加</h3><p>kernel-3.10/drivers/misc/mediatek/imgsensor/src/mt6735/kd_sensorlist.c<br>驱动的注册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">module_init(CAMERA_HW_i2C_init);</div><div class="line">static int __init CAMERA_HW_i2C_init(void)</div><div class="line">&#123;</div><div class="line">  platform_device_register(&amp;camerahw_platform_device);</div><div class="line">  platform_driver_register(&amp;g_stCAMERA_HW_Driver);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int CAMERA_HW_probe(struct platform_device *pdev)</div><div class="line">&#123;</div><div class="line">    return i2c_add_driver(&amp;CAMERA_HW_i2c_driver);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int CAMERA_HW_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)</div><div class="line">&#123;</div><div class="line">    RegisterCAMERA_HWCharDrv();</div><div class="line">    register_camera_sysfs();</div><div class="line">&#125;</div><div class="line"></div><div class="line">inline static int RegisterCAMERA_HWCharDrv(void)</div><div class="line">&#123;</div><div class="line">  cdev_init(g_pCAMERA_HW_CharDrv, &amp;g_stCAMERA_HW_fops);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static const struct file_operations g_stCAMERA_HW_fops =</div><div class="line">&#123;</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .open = CAMERA_HW_Open,</div><div class="line">    .release = CAMERA_HW_Release,</div><div class="line">    .unlocked_ioctl = CAMERA_HW_Ioctl,</div><div class="line">#ifdef CONFIG_COMPAT</div><div class="line">    .compat_ioctl = CAMERA_HW_Ioctl_Compat,</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="定义id和drv-name"><a href="#定义id和drv-name" class="headerlink" title="定义id和drv name"></a>定义id和drv name</h3><p>kernel-3.10/drivers/miscmediatek/custom/common/kernel/imgsensor/inc/kd_imgsensor.h</p>
<h3 id="hal层ID和driver-name的衔接"><a href="#hal层ID和driver-name的衔接" class="headerlink" title="hal层ＩＤ和driver　name的衔接"></a>hal层ＩＤ和driver　name的衔接</h3><p>./vendor/mediatek/proprietary/custom/mt6735/hal/D1/imgsensor_src/sensorlist.cpp</p>
<h3 id="时序配置"><a href="#时序配置" class="headerlink" title="时序配置"></a>时序配置</h3><p>./drivers/misc/mediatek/mach/mt6735/tx6735_65c_xz_l1/camera/camera/kd_camera_hw.c</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之kenel编译</title>
    <link href="http://joyflyaway.com/2018/02/05/Android%E4%B9%8Bkenel%E7%BC%96%E8%AF%91/"/>
    <id>http://joyflyaway.com/2018/02/05/Android之kenel编译/</id>
    <published>2018-02-05T12:35:40.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>make arm=arm64 O=out_path {xxx_defconfig, menuconfig, distclean}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之输入系统</title>
    <link href="http://joyflyaway.com/2018/02/05/Android%E4%B9%8B%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F/"/>
    <id>http://joyflyaway.com/2018/02/05/Android之输入系统/</id>
    <published>2018-02-05T12:31:47.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="android-子系统主要由以下几个模块组成："><a href="#android-子系统主要由以下几个模块组成：" class="headerlink" title="android 子系统主要由以下几个模块组成："></a>android 子系统主要由以下几个模块组成：</h3><p>EventHub：事件的传入是从EventHub开始的，EventHub是事件的抽象结构，维护着系统设备的运行情况，并维护一个所有输入设备的文件描述符<br>Input Reader: 负责从硬件获取输入，转换成事件（Event), 并分发给Input Dispatcher.<br>Input Dispatcher: 将Input Reader传送过来的Events 分发给合适的窗口，并监控ANR。<br>Input Manager Service：负责Input Reader 和 Input Dispatchor的创建，并提供Policy 用于Events的预处理。<br>Window Manager Service：管理Input Manager 与 View（Window) 以及 ActivityManager 之间的通信。<br>View and Activity：接收按键并处理。<br>ActivityManager Service：ANR 处理</p>
<h3 id="getevent"><a href="#getevent" class="headerlink" title="getevent"></a>getevent</h3><p>输入设备插拔或者使用时，数据会实时显示出来</p>
<h3 id="查看外接输入设备"><a href="#查看外接输入设备" class="headerlink" title="查看外接输入设备"></a>查看外接输入设备</h3><p>cat /proc/bus/input/devices</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>驱动问题分析思路</title>
    <link href="http://joyflyaway.com/2018/02/05/%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/"/>
    <id>http://joyflyaway.com/2018/02/05/驱动问题分析思路/</id>
    <published>2018-02-05T12:10:35.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<ol>
<li>先集成驱动</li>
<li>是否生成相应节点或相应数据结构</li>
<li>权限是否正常</li>
</ol>
<h3 id="Kernel驱动"><a href="#Kernel驱动" class="headerlink" title="Kernel驱动"></a>Kernel驱动</h3><p>dump_stack(); 查看调用栈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之gradle</title>
    <link href="http://joyflyaway.com/2018/02/01/Android%E4%B9%8Bgradle/"/>
    <id>http://joyflyaway.com/2018/02/01/Android之gradle/</id>
    <published>2018-02-01T09:54:00.000Z</published>
    <updated>2018-02-05T13:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>构建规则语言：Gradle 选择了 Groovy，Groovy 基于 Java 并拓展了 Java。 Java 程序员可以无缝切换到使用 Groovy 开发程序。Groovy 说白了就是把写 Java 程序变得像写脚本一样简单。写完就可以执行，Groovy 内部会将其编译成 Java class 然后启动虚拟机来执行。</p>
<h3 id="Gradle基础知识："><a href="#Gradle基础知识：" class="headerlink" title="Gradle基础知识："></a>Gradle基础知识：</h3><ul>
<li>Groovy，由于它基于 Java，所以我们仅介绍 Java 之外的东西。了解 Groovy 语言是掌握 Gradle 的基础。</li>
<li>Gradle 作为一个工具，它的行话和它“为人处事”的原则。</li>
</ul>
<p>Gradle中，每一个待编译的工程都叫一个Project。每一个 Project 在构建的时候都包含一系列的Task。比如一个 Android APK 的编译可能包含：Java 源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名 Task 等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之Sensor</title>
    <link href="http://joyflyaway.com/2018/01/29/Android%E4%B9%8BSensor/"/>
    <id>http://joyflyaway.com/2018/01/29/Android之Sensor/</id>
    <published>2018-01-29T06:05:00.000Z</published>
    <updated>2018-02-01T10:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="TYPE-ORIENTATION"><a href="#TYPE-ORIENTATION" class="headerlink" title="TYPE_ORIENTATION"></a>TYPE_ORIENTATION</h3><p>This constant is deprecated.  use SensorManager.getOrientation() instead. ”也就是说，这种方式已经被取消，要开发者使用 SensorManager.getOrientation()来获取原来的数据。实际上，android获取方向是通过磁场感应器和加速度感应器共同获得的，至于具体的算法SDK已经封装好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YUV编码</title>
    <link href="http://joyflyaway.com/2018/01/25/YUV%E7%BC%96%E7%A0%81/"/>
    <id>http://joyflyaway.com/2018/01/25/YUV编码/</id>
    <published>2018-01-25T02:54:41.000Z</published>
    <updated>2018-02-01T10:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>二进制查看工具：bless<br>yuv码流查看工具：vooya</p>
<h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<h3 id="YUV444"><a href="#YUV444" class="headerlink" title="YUV444"></a>YUV444</h3><p>既无损YUV色彩空间.一个Y带一个Cb一个Cr,即YCbCr.</p>
<h3 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h3><p>采样即从YUV444基础上,从第一个Y开始只保留Cb,剔去Cr,第二个Y只保留Cr剔去Cb……这样交替采样,长度大小为width<em>height</em>2,Y:U:V=4:2:2,一个色彩分量占一个字节.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">YUYV、YVYU、UYVY、VYUY，都是YUV422的打包格式——即在内存中，Y、U、V都是挨着排序的。   </div><div class="line">它们的名称就表示了Y、U、V的顺序。像YUYV，就是Y、U、Y、V、Y、U、Y、V。</div></pre></td></tr></table></figure></p>
<h3 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h3><p>即从YUV422基础上进行隔行采样,例如第一行只保留Cb,第二行只保留Cr……这样交替进行,Y:U:V=4:2:0并不是没有V分量,也可以是Y:U:V=4:0:2.相信这样大家容易理解.最后在这个基础上,把Y,U,V三种分量打包排列,即如上图,长度大小为width<em>height</em>3/2.</p>
<h3 id="YUV422P"><a href="#YUV422P" class="headerlink" title="YUV422P"></a>YUV422P</h3><p>YUV422P也属于YUV422的一种，它是一种Plane模式，即平面模式，并不是将YUV数据交错存储，而是先存放所有的Y分量，然后存储所有的U（Cb）分量，最后存储所有的V（Cr）分量，如上图所示。其每一个像素点的YUV值提取方法也是遵循YUV422格式的最基本提取方法，即两个Y共用一个UV。比如，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00。</p>
<h3 id="YV12，YU12"><a href="#YV12，YU12" class="headerlink" title="YV12，YU12"></a>YV12，YU12</h3><p>YU12和YV12属于YUV420格式，也是一种Plane模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00，其他依次类推。</p>
<h3 id="NV12、NV21"><a href="#NV12、NV21" class="headerlink" title="NV12、NV21"></a>NV12、NV21</h3><p>NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。其提取方式与上一种类似，即Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android底层图形系统</title>
    <link href="http://joyflyaway.com/2018/01/19/Android%E5%BA%95%E5%B1%82%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://joyflyaway.com/2018/01/19/Android底层图形系统/</id>
    <published>2018-01-19T09:46:14.000Z</published>
    <updated>2018-02-28T06:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h2><h3 id="什么是OpenGL？"><a href="#什么是OpenGL？" class="headerlink" title="什么是OpenGL？"></a>什么是OpenGL？</h3><p>OpenGL是和编程语言、平台无关的一套interface ，主要是为了渲染 2D 和 3D图形等。一般这套接口是用来和GPU进行交互的，使用GPU进行硬件加速。</p>
<h3 id="什么是OpenGL-ES？"><a href="#什么是OpenGL-ES？" class="headerlink" title="什么是OpenGL ES？"></a>什么是OpenGL ES？</h3><p>OpenGL ES就是专为嵌入式设备设计的，OpenGL ES和OpenGL中的函数接口有一些是不一样，因为嵌入式设备和pc等的硬件处理能力有差距的。</p>
<p>既然OpenGL ES只是一组函数接口，Android平台提供了两种类型的实现：软件实现，硬件实现。</p>
<p>a.硬件实现，前面提到这组函数接口主要是为了和GPU这个硬件进行打交道的。所以各个硬件厂商会提供相关的实现，例如高通平台的adreno解决方案；</p>
<p>b.软件实现，Android自身也提供了一套OpenGL ES的软件实现，不使用GPU，完全用软件实现画图的相关功能，也就是libagl</p>
<h3 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h3><p>那么什么是EGL？EGL是OpenGL ES和底层的native window system之间的接口，承上启下。</p>
<p><img src="https://github.com/joy-chen/ResourceForBlog/blob/master/android/graph/egl.png?raw=true" alt="架构"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android_NDK开发之build.gradle</title>
    <link href="http://joyflyaway.com/2018/01/18/Android-NDK%E5%BC%80%E5%8F%91%E4%B9%8Bbuild-gradle/"/>
    <id>http://joyflyaway.com/2018/01/18/Android-NDK开发之build-gradle/</id>
    <published>2018-01-18T03:28:17.000Z</published>
    <updated>2018-01-19T09:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  sourceSets &#123;</div><div class="line">    main &#123;</div><div class="line">       <span class="comment">//通过设置 jni 目录为空，我们可不使用 apk 插件的 jni 编译功能。在jni目录下编写Android.mk即可</span></div><div class="line">      jniLibs.srcDir <span class="string">'src/main/libs'</span></div><div class="line">      jni.srcDirs = [] <span class="comment">// 设置使用自己编写的Android.mk</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">tasks.withType(JavaCompile) &#123;</div><div class="line">    compileTask -&gt; compileTask.dependsOn ndkBuild</div><div class="line">&#125;</div><div class="line"><span class="function">String <span class="title">getNdkBuildPath</span><span class="params">()</span> </span>&#123;</div><div class="line">    Properties properties = <span class="keyword">new</span> Properties()</div><div class="line">    properties.load(project.rootProject.file(<span class="string">'local.properties'</span>).newDataInputStream())</div><div class="line">    def ndkBuildingDir = properties.getProperty(<span class="string">"ndk.dir"</span>)</div><div class="line">    def ndkBuildPath = <span class="function">ndkBuildingDir</span></div><div class="line">    <span class="title">if</span> <span class="params">(Os.isFamily(Os.FAMILY_WINDOWS)</span>) &#123;</div><div class="line">        ndkBuildPath = ndkBuildingDir + <span class="string">'/ndk-build.cmd'</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ndkBuildPath = ndkBuildingDir + <span class="string">'/ndk-build'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ndkBuildPath</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">task <span class="title">ndkBuild</span><span class="params">(type: Exec, description: <span class="string">'Compile JNI source via NDK'</span>)</span> </span>&#123;</div><div class="line">    println(<span class="string">'executing ndkBuild'</span>)</div><div class="line">    def ndkBuildPath = getNdkBuildPath();</div><div class="line">    commandLine ndkBuildPath, <span class="string">'-j8'</span>, <span class="string">'-C'</span>, file(<span class="string">'src/main'</span>).absolutePath</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">task <span class="title">ndkClean</span><span class="params">(type: Exec, description: <span class="string">'clean JNI libraries'</span>)</span> </span>&#123;</div><div class="line">    println(<span class="string">'executing ndkBuild clean'</span>)</div><div class="line">    def ndkBuildPath = getNdkBuildPath();</div><div class="line">    commandLine ndkBuildPath, <span class="string">'clean'</span>, <span class="string">'-C'</span>, file(<span class="string">'src/main'</span>).absolutePath</div><div class="line">&#125;</div><div class="line"></div><div class="line">clean.dependsOn <span class="string">'ndkClean'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android_NDK开发之Android.mk</title>
    <link href="http://joyflyaway.com/2018/01/17/Android-NDK%E5%BC%80%E5%8F%91/"/>
    <id>http://joyflyaway.com/2018/01/17/Android-NDK开发/</id>
    <published>2018-01-17T10:07:59.000Z</published>
    <updated>2018-01-19T09:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>native代码目录结构：</p>
<ul>
<li>project   <ul>
<li>jni   <ul>
<li>Android.mk   </li>
<li>Application.mk   </li>
</ul>
</li>
<li>libs   <ul>
<li>armeabi   </li>
<li>armeabi-v7a   </li>
<li>xxx.jar   </li>
</ul>
</li>
<li>res   </li>
<li>src   </li>
<li>Android.mk   </li>
<li>AndroidManifest.xml</li>
</ul>
</li>
</ul>
<p>添加三方so库：<br>project/Android.mk:<br>  LOCAL_PREBUILT_JNI_LIBS += xxx.so</p>
<p>project/jni/Application.mk<br>  APP_ABI：设置编译哪些平台库（armeabi armeabi-v7a x86)</p>
<p>project/jni/Android.mk<br>  LOCAL_LDFLAGS 链接库<br>  include $(BUILD_SHARED_LIBRARY) 编译成动态库</p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>打印变量的值：<br>$(warning “the value of LOCAL_PATH is$(LOCAL_PATH)”)  </p>
<p>示例1:</p>
<ul>
<li>project   <ul>
<li>lib   <ul>
<li>armeabi   <ul>
<li>xxx.so   </li>
</ul>
</li>
</ul>
</li>
<li>Android.mk   </li>
<li>xxx.apk   </li>
</ul>
</li>
</ul>
<p>Android.mk写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)</div><div class="line">include $(CLEAR_VARS)M</div><div class="line"></div><div class="line">LOCAL_MODULE := xxx</div><div class="line">LOCAL_MODULE_TAGS := optional</div><div class="line">LOCAL_SRC_FILES := xxx.apk</div><div class="line">LOCAL_MODULE_CLASS := APPS</div><div class="line">LOCAL_CERTIFICATE := PRESIGNED</div><div class="line">LOCAL_PREBUILT_JNI_LIBS:= \</div><div class="line">lib/armeabi/xxx.so</div><div class="line"></div><div class="line">include $(BUILD_PREBUILT)</div></pre></td></tr></table></figure></p>
<h2 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h2><h3 id="LOCAL-EXPORT-C-INCLUDES"><a href="#LOCAL-EXPORT-C-INCLUDES" class="headerlink" title="LOCAL_EXPORT_C_INCLUDES"></a>LOCAL_EXPORT_C_INCLUDES</h3><p>定义确保了任何依赖这个预编译库的模块会自动在自己的 LOCAL_C_INCLUDES 变量中增加到这个预编译库的include目录的路径，从而能够找到其中的头文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android中系统属性的获取</title>
    <link href="http://joyflyaway.com/2018/01/17/android%E4%B8%AD%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>http://joyflyaway.com/2018/01/17/android中系统属性的获取/</id>
    <published>2018-01-17T09:16:09.000Z</published>
    <updated>2018-01-17T09:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="获取java属性："><a href="#获取java属性：" class="headerlink" title="获取java属性："></a>获取java属性：</h3><p>System.getProperty(“user.name”)；</p>
<h3 id="三方应用获取系统属性："><a href="#三方应用获取系统属性：" class="headerlink" title="三方应用获取系统属性："></a>三方应用获取系统属性：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getAndroidOsSystemProperties</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    String ret;</div><div class="line">    Method systemProperties_get = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        systemProperties_get = Class.forName(<span class="string">"android.os.SystemProperties"</span>).getMethod(<span class="string">"get"</span>, String.class);</div><div class="line">        <span class="keyword">if</span> ((ret = (String) systemProperties_get.invoke(<span class="keyword">null</span>, key)) != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内置应用获取系统属性："><a href="#内置应用获取系统属性：" class="headerlink" title="内置应用获取系统属性："></a>内置应用获取系统属性：</h3><p>SystemProperties.get(“property_name”))</p>
<p><a href="http://joyflyaway.com/2016/10/24/Android系统属性/">相关参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C本质</title>
    <link href="http://joyflyaway.com/2018/01/17/C%E6%9C%AC%E8%B4%A8/"/>
    <id>http://joyflyaway.com/2018/01/17/C本质/</id>
    <published>2018-01-17T07:01:56.000Z</published>
    <updated>2018-01-17T09:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>对于局部变量来说：将其放在 data 段，即初始化一次，且限定作用域为定义的函数或语句块。<br>对于全局变量和函数来说：限定其作用域在本文件中</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>对于全局变量来说：将变量放在rodata段，由MMU通过页表项的权限位保证其只读属性<br>对于局部变量来说：变量依然放在栈里，由编译器保证其只读属性<br>const 修饰数组，数组每个元素的值都不能改变</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof是关键字<br>sizeof接具体数字时可不加括号，接类型时一定要加括号</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>两个基本作用：<br>1.禁止编译其优化其修饰代码<br>2.用在汇编，asm volatile, 禁止编译器对代码的优化（顺序及删减）</p>
<h3 id="关于地址"><a href="#关于地址" class="headerlink" title="关于地址"></a>关于地址</h3><p>物理地址:外设(内存)在总线上的实际地址<br>虚拟地址:开启 MMU 之后，程序中指令或数据的地址。虚拟地址最终被 MMU 映射到内存在总线上的物理地址<br>绝对地址:程序运行时指令或数据的地址<br>相对地址:相对与PC的地址<br>链接地址:由链接器确定的load到内存的地址</p>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul>
<li>指针可以为 NULL，引用不能为空值</li>
<li>引用的值不可改变，而指针的值可以改变</li>
</ul>
<h2 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h2><p>1.从 x = y 所看到的：这只是一组 load store 指令<br>ex:ldr r0, [fp, #-8] ldr y 的值 str r0, [fp, #-12] str 到 x 的地址<br>编译器为每个变量分配地址，每个符号的地址在编译时已经确定（即 load 地址）的，如果编译器需要一个地址（可能加上偏移量）来操作，他可以直接操作，并不需要增加指令首先获取具体的地址   </p>
<p>2.char <em>p = “abcdef”; 与 char p[] = “abcdef”;的区别<br>首先：“abcdef”是存放再 rodata 段的 char </em>p = “abcdef”; 只为指针 p 开辟一个空间，指向 rodata 段的字符串，不可以修改 char p[] = “abcdef”;用时将字符串拷贝到栈里（如果局部）即开辟空间，可以修改；   </p>
<p>3.syscall 的过程（以 arm 平台，mount 函数为例）：<br>mount（） {<br>  swi #n<br>}<br>此条指令有 sub lr， pc， #4； mov pc，#0x08 的动作<br>切换到内核模式（swi 异常模式），pc 指向对应的异常入口地址并跳转执行， 0x08： b handle_swi;<br>handle_swi: stmfd sp!, {r0-r12, lr} b swi_handle ldmfd sp!, {r0-r12, pc}<br>swi_handle(int n) {<br>  (syscall[n])();<br>}<br>此时可以根据 ldr r0，[lr, #-4] bic r0, r0, 0xff000000 得到系统调用号 n。</p>
<p>4.进程和线程：<br>进程是资源的基本单位，线程是调度的基本单位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
