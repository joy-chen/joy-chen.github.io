<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joy</title>
  <subtitle>abc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joyflyaway.com/"/>
  <updated>2018-02-23T09:28:09.000Z</updated>
  <id>http://joyflyaway.com/</id>
  
  <author>
    <name>Joy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MTK之lcm架构</title>
    <link href="http://joyflyaway.com/2018/02/22/MTK%E4%B9%8Blcm%E6%9E%B6%E6%9E%84/"/>
    <id>http://joyflyaway.com/2018/02/22/MTK之lcm架构/</id>
    <published>2018-02-22T09:24:36.000Z</published>
    <updated>2018-02-23T09:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>Linux kernel有一些总线，比如USB、I2C等。对于每一个总线都会有一些设备和驱动挂在上面。驱动服务于匹配的设备，使Linux正确的操作硬件设备。当一个设备或者驱动注册到特定的总线上的时候就会触发总线匹配函数，比如一个设备注册到了总线，所有的该总线的驱动都会被枚举，判断是不是可以服务于新添加的设备（一般通过name来匹配），反之亦然。<br>如果总线匹配成功，就会调用驱动的probe函数，检查指定的硬件确实存在，然后确定是否所需的资源都能够从系统申请。<br>事实上，设备或者驱动能够正确的合作，在probe之后，模块初始化顺序决定于probe的执行顺序，可以由BSP函数中注册设备的顺序控制。MT6572平台，L版本的BSP文件放在kernel/arch/arm/mach-mt6572/mt_devs.c,mt_board_init()函数控制着probe的顺序。<br>platform虚拟总线，关联在该总线的设备和驱动通过name来匹配。</p>
<h3 id="源码路径"><a href="#源码路径" class="headerlink" title="源码路径"></a>源码路径</h3><p>drivers/misc/mediatek/lcm/mt65xx_lcm_list.c<br>arch/arm64/configs/tx6735_65c_xz_l1_defconfig</p>
<p>arch/arm64/configs/tx6735_65c_xz_l1_defconfig<br>CUSTOM_KERNEL_LCM = xxx  //对应lcm目录驱动的子目录名<br>配置驱动</p>
<h3 id="drivers-misc-mediatek-mach-mt6735-mt-devs-c"><a href="#drivers-misc-mediatek-mach-mt6735-mt-devs-c" class="headerlink" title="drivers/misc/mediatek/mach/mt6735/mt_devs.c"></a>drivers/misc/mediatek/mach/mt6735/mt_devs.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__init int mt_board_init(void) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-videox-mt6735-mtkfb-c"><a href="#drivers-misc-mediatek-videox-mt6735-mtkfb-c" class="headerlink" title="./drivers/misc/mediatek/videox/mt6735/mtkfb.c"></a>./drivers/misc/mediatek/videox/mt6735/mtkfb.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">static struct fb_ops mtkfb_ops = &#123;</div><div class="line">    .owner          = THIS_MODULE,</div><div class="line">    .fb_open        = mtkfb_open,</div><div class="line">    .fb_release     = mtkfb_release,</div><div class="line">    .fb_setcolreg   = mtkfb_setcolreg,</div><div class="line">    .fb_pan_display = mtkfb_pan_display_proxy,</div><div class="line">    .fb_fillrect    = cfb_fillrect,</div><div class="line">    .fb_copyarea    = cfb_copyarea,</div><div class="line">    .fb_imageblit   = cfb_imageblit,</div><div class="line">    .fb_cursor      = mtkfb_soft_cursor,</div><div class="line">    .fb_check_var   = mtkfb_check_var,</div><div class="line">    .fb_set_par     = mtkfb_set_par,</div><div class="line">    .fb_ioctl       = mtkfb_ioctl,</div><div class="line">#ifdef CONFIG_COMPAT</div><div class="line">	.fb_compat_ioctl = mtkfb_compat_ioctl,</div><div class="line">#endif    </div><div class="line">#ifdef CONFIG_DMA_SHARED_BUFFER</div><div class="line">    .fb_dmabuf_export = mtkfb_dmabuf_export,</div><div class="line">#endif</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static struct platform_driver mtkfb_driver =</div><div class="line">&#123;</div><div class="line">    .driver = &#123;</div><div class="line">        .name    = MTKFB_DRIVER,</div><div class="line">#ifdef CONFIG_PM</div><div class="line">        .pm     = &amp;mtkfb_pm_ops,</div><div class="line">#endif</div><div class="line">        .bus     = &amp;platform_bus_type,</div><div class="line">        .probe   = mtkfb_probe,</div><div class="line">        .remove  = mtkfb_remove,</div><div class="line">        .suspend = mtkfb_suspend,</div><div class="line">        .resume  = mtkfb_resume,</div><div class="line">	.shutdown = mtkfb_shutdown,</div><div class="line">	.of_match_table = mtkfb_of_ids,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div><div class="line">static int mtkfb_probe(struct device *dev) ｛</div><div class="line">  primary_display_init(mtkfb_find_lcm_driver(), lcd_fps);</div><div class="line">  mtkfb_fbinfo_init(fbi);</div><div class="line">  mtkfb_register_sysfs(fbdev);</div><div class="line">  register_framebuffer(fbi);</div><div class="line">｝</div><div class="line">mtk_fb_probe函数主要做的工作如下：</div><div class="line">Called by LDM binding to probe andattach a new device.</div><div class="line"> * Initialization sequence:</div><div class="line"> *   1.allocate system fb_info structure</div><div class="line"> *     select panel type according to machine type</div><div class="line"> *   2.init LCD panel</div><div class="line"> *   3.init LCD controller and LCD DMA</div><div class="line"> *   4.init system fb_info structure</div><div class="line"> *   5.init gfx DMA</div><div class="line"> *   6.enable LCD panel</div><div class="line">       start LCD frame transfer</div><div class="line"> *   7.register system fb_info structure</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-videox-mt6735-primary-display-c"><a href="#drivers-misc-mediatek-videox-mt6735-primary-display-c" class="headerlink" title="./drivers/misc/mediatek/videox/mt6735/primary_display.c"></a>./drivers/misc/mediatek/videox/mt6735/primary_display.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int primary_display_init(char *lcm_name, unsigned int lcm_fps) &#123;</div><div class="line">  disp_lcm_probe( lcm_name, LCM_INTERFACE_NOTDEFINED);</div><div class="line">  disp_lcm_init(pgc-&gt;plcm, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-videox-mt6735-disp-lcm-c"><a href="#drivers-misc-mediatek-videox-mt6735-disp-lcm-c" class="headerlink" title="./drivers/misc/mediatek/videox/mt6735/disp_lcm.c"></a>./drivers/misc/mediatek/videox/mt6735/disp_lcm.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">disp_lcm_handle* disp_lcm_probe(char* plcm_name, LCM_INTERFACE_ID lcm_id)</div><div class="line">&#123;</div><div class="line">  lcm_drv = lcm_driver_list[0];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="drivers-misc-mediatek-lcm-mt65xx-lcm-list-c"><a href="#drivers-misc-mediatek-lcm-mt65xx-lcm-list-c" class="headerlink" title="drivers/misc/mediatek/lcm/mt65xx_lcm_list.c"></a>drivers/misc/mediatek/lcm/mt65xx_lcm_list.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">驱动列表</div><div class="line">LCM_DRIVER* lcm_driver_list[] = &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之gradle</title>
    <link href="http://joyflyaway.com/2018/02/01/Android%E4%B9%8Bgradle/"/>
    <id>http://joyflyaway.com/2018/02/01/Android之gradle/</id>
    <published>2018-02-01T09:54:00.000Z</published>
    <updated>2018-02-05T13:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>构建规则语言：Gradle 选择了 Groovy，Groovy 基于 Java 并拓展了 Java。 Java 程序员可以无缝切换到使用 Groovy 开发程序。Groovy 说白了就是把写 Java 程序变得像写脚本一样简单。写完就可以执行，Groovy 内部会将其编译成 Java class 然后启动虚拟机来执行。</p>
<h3 id="Gradle基础知识："><a href="#Gradle基础知识：" class="headerlink" title="Gradle基础知识："></a>Gradle基础知识：</h3><ul>
<li>Groovy，由于它基于 Java，所以我们仅介绍 Java 之外的东西。了解 Groovy 语言是掌握 Gradle 的基础。</li>
<li>Gradle 作为一个工具，它的行话和它“为人处事”的原则。</li>
</ul>
<p>Gradle中，每一个待编译的工程都叫一个Project。每一个 Project 在构建的时候都包含一系列的Task。比如一个 Android APK 的编译可能包含：Java 源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名 Task 等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之Sensor</title>
    <link href="http://joyflyaway.com/2018/01/29/Android%E4%B9%8BSensor/"/>
    <id>http://joyflyaway.com/2018/01/29/Android之Sensor/</id>
    <published>2018-01-29T06:05:00.000Z</published>
    <updated>2018-02-01T10:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="TYPE-ORIENTATION"><a href="#TYPE-ORIENTATION" class="headerlink" title="TYPE_ORIENTATION"></a>TYPE_ORIENTATION</h3><p>This constant is deprecated.  use SensorManager.getOrientation() instead. ”也就是说，这种方式已经被取消，要开发者使用 SensorManager.getOrientation()来获取原来的数据。实际上，android获取方向是通过磁场感应器和加速度感应器共同获得的，至于具体的算法SDK已经封装好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YUV编码</title>
    <link href="http://joyflyaway.com/2018/01/25/YUV%E7%BC%96%E7%A0%81/"/>
    <id>http://joyflyaway.com/2018/01/25/YUV编码/</id>
    <published>2018-01-25T02:54:41.000Z</published>
    <updated>2018-02-01T10:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>二进制查看工具：bless<br>yuv码流查看工具：vooya</p>
<h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<h3 id="YUV444"><a href="#YUV444" class="headerlink" title="YUV444"></a>YUV444</h3><p>既无损YUV色彩空间.一个Y带一个Cb一个Cr,即YCbCr.</p>
<h3 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h3><p>采样即从YUV444基础上,从第一个Y开始只保留Cb,剔去Cr,第二个Y只保留Cr剔去Cb……这样交替采样,长度大小为width<em>height</em>2,Y:U:V=4:2:2,一个色彩分量占一个字节.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">YUYV、YVYU、UYVY、VYUY，都是YUV422的打包格式——即在内存中，Y、U、V都是挨着排序的。   </div><div class="line">它们的名称就表示了Y、U、V的顺序。像YUYV，就是Y、U、Y、V、Y、U、Y、V。</div></pre></td></tr></table></figure></p>
<h3 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h3><p>即从YUV422基础上进行隔行采样,例如第一行只保留Cb,第二行只保留Cr……这样交替进行,Y:U:V=4:2:0并不是没有V分量,也可以是Y:U:V=4:0:2.相信这样大家容易理解.最后在这个基础上,把Y,U,V三种分量打包排列,即如上图,长度大小为width<em>height</em>3/2.</p>
<h3 id="YUV422P"><a href="#YUV422P" class="headerlink" title="YUV422P"></a>YUV422P</h3><p>YUV422P也属于YUV422的一种，它是一种Plane模式，即平面模式，并不是将YUV数据交错存储，而是先存放所有的Y分量，然后存储所有的U（Cb）分量，最后存储所有的V（Cr）分量，如上图所示。其每一个像素点的YUV值提取方法也是遵循YUV422格式的最基本提取方法，即两个Y共用一个UV。比如，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00。</p>
<h3 id="YV12，YU12"><a href="#YV12，YU12" class="headerlink" title="YV12，YU12"></a>YV12，YU12</h3><p>YU12和YV12属于YUV420格式，也是一种Plane模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00，其他依次类推。</p>
<h3 id="NV12、NV21"><a href="#NV12、NV21" class="headerlink" title="NV12、NV21"></a>NV12、NV21</h3><p>NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。其提取方式与上一种类似，即Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android底层图形系统</title>
    <link href="http://joyflyaway.com/2018/01/19/Android%E5%BA%95%E5%B1%82%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://joyflyaway.com/2018/01/19/Android底层图形系统/</id>
    <published>2018-01-19T09:46:14.000Z</published>
    <updated>2018-01-19T10:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h2><h3 id="什么是OpenGL？"><a href="#什么是OpenGL？" class="headerlink" title="什么是OpenGL？"></a>什么是OpenGL？</h3><p>OpenGL是和编程语言、平台无关的一套interface ，主要是为了渲染 2D 和 3D图形等。一般这套接口是用来和GPU进行交互的，使用GPU进行硬件加速。</p>
<h3 id="什么是OpenGL-ES？"><a href="#什么是OpenGL-ES？" class="headerlink" title="什么是OpenGL ES？"></a>什么是OpenGL ES？</h3><p>OpenGL ES就是专为嵌入式设备设计的，OpenGL ES和OpenGL中的函数接口有一些是不一样，因为嵌入式设备和pc等的硬件处理能力有差距的。</p>
<p>既然OpenGL ES只是一组函数接口，Android平台提供了两种类型的实现：软件实现，硬件实现。</p>
<p>a.硬件实现，前面提到这组函数接口主要是为了和GPU这个硬件进行打交道的。所以各个硬件厂商会提供相关的实现，例如高通平台的adreno解决方案；</p>
<p>b.软件实现，Android自身也提供了一套OpenGL ES的软件实现，不使用GPU，完全用软件实现画图的相关功能，也就是libagl</p>
<h3 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h3><p>那么什么是EGL？EGL是OpenGL ES和底层的native window system之间的接口，承上启下。</p>
<p><img src="https://github.com/joy-chen/ResourceForBlog/blob/master/android/graph/egl.png?raw=true" alt="架构"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;OpenGL-ES&quot;&gt;&lt;a href=&quot;#OpenGL-ES&quot; class=&quot;headerlink&quot; title=&quot;OpenGL ES&quot;&gt;&lt;/a&gt;OpenGL ES&lt;/h2&gt;&lt;h3 id=&quot;什么是OpenGL？&quot;&gt;&lt;a href=&quot;#什么是OpenGL？&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android_NDK开发之build.gradle</title>
    <link href="http://joyflyaway.com/2018/01/18/Android-NDK%E5%BC%80%E5%8F%91%E4%B9%8Bbuild-gradle/"/>
    <id>http://joyflyaway.com/2018/01/18/Android-NDK开发之build-gradle/</id>
    <published>2018-01-18T03:28:17.000Z</published>
    <updated>2018-01-19T09:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  sourceSets &#123;</div><div class="line">    main &#123;</div><div class="line">       <span class="comment">//通过设置 jni 目录为空，我们可不使用 apk 插件的 jni 编译功能。在jni目录下编写Android.mk即可</span></div><div class="line">      jniLibs.srcDir <span class="string">'src/main/libs'</span></div><div class="line">      jni.srcDirs = [] <span class="comment">// 设置使用自己编写的Android.mk</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">tasks.withType(JavaCompile) &#123;</div><div class="line">    compileTask -&gt; compileTask.dependsOn ndkBuild</div><div class="line">&#125;</div><div class="line"><span class="function">String <span class="title">getNdkBuildPath</span><span class="params">()</span> </span>&#123;</div><div class="line">    Properties properties = <span class="keyword">new</span> Properties()</div><div class="line">    properties.load(project.rootProject.file(<span class="string">'local.properties'</span>).newDataInputStream())</div><div class="line">    def ndkBuildingDir = properties.getProperty(<span class="string">"ndk.dir"</span>)</div><div class="line">    def ndkBuildPath = <span class="function">ndkBuildingDir</span></div><div class="line">    <span class="title">if</span> <span class="params">(Os.isFamily(Os.FAMILY_WINDOWS)</span>) &#123;</div><div class="line">        ndkBuildPath = ndkBuildingDir + <span class="string">'/ndk-build.cmd'</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ndkBuildPath = ndkBuildingDir + <span class="string">'/ndk-build'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ndkBuildPath</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">task <span class="title">ndkBuild</span><span class="params">(type: Exec, description: <span class="string">'Compile JNI source via NDK'</span>)</span> </span>&#123;</div><div class="line">    println(<span class="string">'executing ndkBuild'</span>)</div><div class="line">    def ndkBuildPath = getNdkBuildPath();</div><div class="line">    commandLine ndkBuildPath, <span class="string">'-j8'</span>, <span class="string">'-C'</span>, file(<span class="string">'src/main'</span>).absolutePath</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">task <span class="title">ndkClean</span><span class="params">(type: Exec, description: <span class="string">'clean JNI libraries'</span>)</span> </span>&#123;</div><div class="line">    println(<span class="string">'executing ndkBuild clean'</span>)</div><div class="line">    def ndkBuildPath = getNdkBuildPath();</div><div class="line">    commandLine ndkBuildPath, <span class="string">'clean'</span>, <span class="string">'-C'</span>, file(<span class="string">'src/main'</span>).absolutePath</div><div class="line">&#125;</div><div class="line"></div><div class="line">clean.dependsOn <span class="string">'ndkClean'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android_NDK开发之Android.mk</title>
    <link href="http://joyflyaway.com/2018/01/17/Android-NDK%E5%BC%80%E5%8F%91/"/>
    <id>http://joyflyaway.com/2018/01/17/Android-NDK开发/</id>
    <published>2018-01-17T10:07:59.000Z</published>
    <updated>2018-01-19T09:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>native代码目录结构：</p>
<ul>
<li>project   <ul>
<li>jni   <ul>
<li>Android.mk   </li>
<li>Application.mk   </li>
</ul>
</li>
<li>libs   <ul>
<li>armeabi   </li>
<li>armeabi-v7a   </li>
<li>xxx.jar   </li>
</ul>
</li>
<li>res   </li>
<li>src   </li>
<li>Android.mk   </li>
<li>AndroidManifest.xml</li>
</ul>
</li>
</ul>
<p>添加三方so库：<br>project/Android.mk:<br>  LOCAL_PREBUILT_JNI_LIBS += xxx.so</p>
<p>project/jni/Application.mk<br>  APP_ABI：设置编译哪些平台库（armeabi armeabi-v7a x86)</p>
<p>project/jni/Android.mk<br>  LOCAL_LDFLAGS 链接库<br>  include $(BUILD_SHARED_LIBRARY) 编译成动态库</p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>打印变量的值：<br>$(warning “the value of LOCAL_PATH is$(LOCAL_PATH)”)  </p>
<p>示例1:</p>
<ul>
<li>project   <ul>
<li>lib   <ul>
<li>armeabi   <ul>
<li>xxx.so   </li>
</ul>
</li>
</ul>
</li>
<li>Android.mk   </li>
<li>xxx.apk   </li>
</ul>
</li>
</ul>
<p>Android.mk写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)</div><div class="line">include $(CLEAR_VARS)M</div><div class="line"></div><div class="line">LOCAL_MODULE := xxx</div><div class="line">LOCAL_MODULE_TAGS := optional</div><div class="line">LOCAL_SRC_FILES := xxx.apk</div><div class="line">LOCAL_MODULE_CLASS := APPS</div><div class="line">LOCAL_CERTIFICATE := PRESIGNED</div><div class="line">LOCAL_PREBUILT_JNI_LIBS:= \</div><div class="line">lib/armeabi/xxx.so</div><div class="line"></div><div class="line">include $(BUILD_PREBUILT)</div></pre></td></tr></table></figure></p>
<h2 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h2><h3 id="LOCAL-EXPORT-C-INCLUDES"><a href="#LOCAL-EXPORT-C-INCLUDES" class="headerlink" title="LOCAL_EXPORT_C_INCLUDES"></a>LOCAL_EXPORT_C_INCLUDES</h3><p>定义确保了任何依赖这个预编译库的模块会自动在自己的 LOCAL_C_INCLUDES 变量中增加到这个预编译库的include目录的路径，从而能够找到其中的头文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android中系统属性的获取</title>
    <link href="http://joyflyaway.com/2018/01/17/android%E4%B8%AD%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>http://joyflyaway.com/2018/01/17/android中系统属性的获取/</id>
    <published>2018-01-17T09:16:09.000Z</published>
    <updated>2018-01-17T09:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="获取java属性："><a href="#获取java属性：" class="headerlink" title="获取java属性："></a>获取java属性：</h3><p>System.getProperty(“user.name”)；</p>
<h3 id="三方应用获取系统属性："><a href="#三方应用获取系统属性：" class="headerlink" title="三方应用获取系统属性："></a>三方应用获取系统属性：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getAndroidOsSystemProperties</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    String ret;</div><div class="line">    Method systemProperties_get = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        systemProperties_get = Class.forName(<span class="string">"android.os.SystemProperties"</span>).getMethod(<span class="string">"get"</span>, String.class);</div><div class="line">        <span class="keyword">if</span> ((ret = (String) systemProperties_get.invoke(<span class="keyword">null</span>, key)) != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内置应用获取系统属性："><a href="#内置应用获取系统属性：" class="headerlink" title="内置应用获取系统属性："></a>内置应用获取系统属性：</h3><p>SystemProperties.get(“property_name”))</p>
<p><a href="http://joyflyaway.com/2016/10/24/Android系统属性/">相关参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C本质</title>
    <link href="http://joyflyaway.com/2018/01/17/C%E6%9C%AC%E8%B4%A8/"/>
    <id>http://joyflyaway.com/2018/01/17/C本质/</id>
    <published>2018-01-17T07:01:56.000Z</published>
    <updated>2018-01-17T09:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>对于局部变量来说：将其放在 data 段，即初始化一次，且限定作用域为定义的函数或语句块。<br>对于全局变量和函数来说：限定其作用域在本文件中</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>对于全局变量来说：将变量放在rodata段，由MMU通过页表项的权限位保证其只读属性<br>对于局部变量来说：变量依然放在栈里，由编译器保证其只读属性<br>const 修饰数组，数组每个元素的值都不能改变</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof是关键字<br>sizeof接具体数字时可不加括号，接类型时一定要加括号</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>两个基本作用：<br>1.禁止编译其优化其修饰代码<br>2.用在汇编，asm volatile, 禁止编译器对代码的优化（顺序及删减）</p>
<h3 id="关于地址"><a href="#关于地址" class="headerlink" title="关于地址"></a>关于地址</h3><p>物理地址:外设(内存)在总线上的实际地址<br>虚拟地址:开启 MMU 之后，程序中指令或数据的地址。虚拟地址最终被 MMU 映射到内存在总线上的物理地址<br>绝对地址:程序运行时指令或数据的地址<br>相对地址:相对与PC的地址<br>链接地址:由链接器确定的load到内存的地址</p>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul>
<li>指针可以为 NULL，引用不能为空值</li>
<li>引用的值不可改变，而指针的值可以改变</li>
</ul>
<h2 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h2><p>1.从 x = y 所看到的：这只是一组 load store 指令<br>ex:ldr r0, [fp, #-8] ldr y 的值 str r0, [fp, #-12] str 到 x 的地址<br>编译器为每个变量分配地址，每个符号的地址在编译时已经确定（即 load 地址）的，如果编译器需要一个地址（可能加上偏移量）来操作，他可以直接操作，并不需要增加指令首先获取具体的地址   </p>
<p>2.char <em>p = “abcdef”; 与 char p[] = “abcdef”;的区别<br>首先：“abcdef”是存放再 rodata 段的 char </em>p = “abcdef”; 只为指针 p 开辟一个空间，指向 rodata 段的字符串，不可以修改 char p[] = “abcdef”;用时将字符串拷贝到栈里（如果局部）即开辟空间，可以修改；   </p>
<p>3.syscall 的过程（以 arm 平台，mount 函数为例）：<br>mount（） {<br>  swi #n<br>}<br>此条指令有 sub lr， pc， #4； mov pc，#0x08 的动作<br>切换到内核模式（swi 异常模式），pc 指向对应的异常入口地址并跳转执行， 0x08： b handle_swi;<br>handle_swi: stmfd sp!, {r0-r12, lr} b swi_handle ldmfd sp!, {r0-r12, pc}<br>swi_handle(int n) {<br>  (syscall[n])();<br>}<br>此时可以根据 ldr r0，[lr, #-4] bic r0, r0, 0xff000000 得到系统调用号 n。</p>
<p>4.进程和线程：<br>进程是资源的基本单位，线程是调度的基本单位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gradle相关用法</title>
    <link href="http://joyflyaway.com/2018/01/14/gradle%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/"/>
    <id>http://joyflyaway.com/2018/01/14/gradle相关用法/</id>
    <published>2018-01-14T10:46:21.000Z</published>
    <updated>2018-01-17T09:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h3><p>include :表示工程包含哪些module，包含的工程将会编译</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之Alarm框架</title>
    <link href="http://joyflyaway.com/2018/01/10/Android%E4%B9%8BAlarm%E6%A1%86%E6%9E%B6/"/>
    <id>http://joyflyaway.com/2018/01/10/Android之Alarm框架/</id>
    <published>2018-01-10T07:29:48.000Z</published>
    <updated>2018-01-17T09:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android问题定位总结</title>
    <link href="http://joyflyaway.com/2018/01/04/Android%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/"/>
    <id>http://joyflyaway.com/2018/01/04/Android问题定位总结/</id>
    <published>2018-01-04T08:27:05.000Z</published>
    <updated>2018-01-17T10:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="Android进程终止和重启问题"><a href="#Android进程终止和重启问题" class="headerlink" title="Android进程终止和重启问题"></a>Android进程终止和重启问题</h3><p>原因是：虚拟机捕获了一些unchecked异常，如空指针异常等<br>在ddms或logcat或bugreport的log中搜索FATAL关键字，或者在/data/system/dropbox目录中找对应生成的crash字段的文件</p>
<h3 id="异常相关的log目录"><a href="#异常相关的log目录" class="headerlink" title="异常相关的log目录"></a>异常相关的log目录</h3><p>/data/anr<br>/data/system/dropbox<br>/data/dontpanic/<br>/data/tombstones/</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK_OTA分析</title>
    <link href="http://joyflyaway.com/2017/12/28/MTK-OTA%E5%88%86%E6%9E%90/"/>
    <id>http://joyflyaway.com/2017/12/28/MTK-OTA分析/</id>
    <published>2017-12-28T12:44:24.000Z</published>
    <updated>2018-02-22T09:26:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="SystemUpdate"><a href="#SystemUpdate" class="headerlink" title="SystemUpdate"></a>SystemUpdate</h3><p>MainEntry<br>  onStart()<br>    bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE);<br>      onServiceConnected()<br>        queryPackagesInternal();<br>          mService.queryPackages();<br>            sQueryNewVersionThread.start();<br>              mHttpManager.queryNewVersion();<br>                checkNewVersion()</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查看调用栈</title>
    <link href="http://joyflyaway.com/2017/12/28/%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <id>http://joyflyaway.com/2017/12/28/查看调用栈/</id>
    <published>2017-12-28T12:18:14.000Z</published>
    <updated>2017-12-29T10:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<ol>
<li>Java中打印调用栈<br>比较简单，利用Throwable，直接log中打印出来：<br>Log.d(TAG, Log.getStackTraceString(new Throwable()));   </li>
</ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;ol&gt;
&lt;li&gt;Java中打印调用栈&lt;br&gt;比较简单，利用Throwable，直接log中打印出来：&lt;br&gt;Log.d(TAG, Log.getStackTraceString(new Throwable()));   &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rk3288_OTA</title>
    <link href="http://joyflyaway.com/2017/12/25/rk3288-OTA/"/>
    <id>http://joyflyaway.com/2017/12/25/rk3288-OTA/</id>
    <published>2017-12-25T11:56:32.000Z</published>
    <updated>2017-12-29T10:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>OTA整个功能代码分布：服务端，recovery，framework层，以及apk共同组成<br>  APK(vendor/rockchip/common/apps/RKUpdateService)<br>  RK只提供apk，没有源码。反编译，apk的主要功能是从服务器下载ota包到本地，<br>  然后写入参数提供给recovery，然后重启进入recovery。</p>
<p>系统升级分为OTA升级和固件包升级<br>OTA方式：<br>1)写如下字段到/cache/recovery/last_flag<br>updating$path=/mnt/internal_sd/update.zip<br>2)写如下字段到/cache/recovery/command<br>–update_package=/mnt/internal_sd/update.zip<br>–locale=en_US<br>3)在adb shell中运行reboot recovery</p>
<h3 id="固件包方式："><a href="#固件包方式：" class="headerlink" title="固件包方式："></a>固件包方式：</h3><p>1)写如下字段到/cache/recovery/last_flag<br>updating$path=/mnt/internal_sd/update.img<br>2)写如下字段到/cache/recovery/command<br>–update_rkimage=/mnt/internal_sd/update.img<br>–locale=en_US<br>3)在adb shell中运行reboot recovery</p>
<h3 id="OTA升级失败排查"><a href="#OTA升级失败排查" class="headerlink" title="OTA升级失败排查:"></a>OTA升级失败排查:</h3><p><a href="http://blog.csdn.net/luzhenrong45/article/details/62042400" target="_blank" rel="external">http://blog.csdn.net/luzhenrong45/article/details/62042400</a></p>
<h3 id="dd命令："><a href="#dd命令：" class="headerlink" title="dd命令："></a>dd命令：</h3><p>  dd备份分区：<br>    df查看各分区使用<br>    mount查看挂载路径<br>    ls /dev/block／platform/xxx/ 查看各分区<br>    cat proc/partitions 查看各分区大小<br>  备份system分区：<br>  dd if=/dev/block/platform/ff0f0000.rksdmmc/by-name/system of=/sdcard/system.img<br>  挂载：mount -t ext4 system.img dest_path<br>  <a href="http://blog.csdn.net/u014134180/article/details/78120143" target="_blank" rel="external">http://blog.csdn.net/u014134180/article/details/78120143</a></p>
<h3 id="recovery相关部分的代码路径"><a href="#recovery相关部分的代码路径" class="headerlink" title="recovery相关部分的代码路径"></a>recovery相关部分的代码路径</h3><p>  ${code_root}/bootable/recovery<br>  ${code_root}/bootable/recovery/recovery.cpp<br>  ${code_root}/bootable/recovery/rkimage.cpp<br>  ${code_root}/frameworks/base/core/java/android/os/RecoverySystem.java</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>The recovery tool communicates with the main system through /cache files.<br>/cache/recovery/command - INPUT - command line for tool, one arg per line<br>/cache/recovery/log - OUTPUT - combined log file from recovery run(s)<br>/cache/recovery/intent - OUTPUT - intent that was passed in</p>
<p>The arguments which may be supplied in the recovery.command file:   </p>
<ul>
<li>–send_intent=anystring - write the text out to recovery.intent</li>
<li>–update_package=path - verify install an OTA package file</li>
<li>–wipe_data - erase user data (and cache), then reboot</li>
<li>–wipe_cache - wipe cache (but not user data), then reboot</li>
<li>–set_encrypted_filesystem=on|off - enables / diasables encrypted fs</li>
<li>–just_exit - do nothing; exit and reboot<br>Arguments may also be supplied in the bootloader control block (BCB).</li>
</ul>
<p>After completing, we remove /cache/recovery/command and reboot.</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>app执行安装/重置/清楚缓存操作调用代码文件<br>  frameworks/base/core/java/android/os/RecoverySystem.java<br>    installPackage<br>    rebootWipeUserData<br>    rebootWipeCache</p>
<p>上面的所有操作都是往/cache/recovery/command文件中写入不同的命令，在进入recovery后（recovery.cpp）对command的关键字进行判断，执行相应的操作</p>
<p>recovery.cpp<br>  -main()<br>   -&gt;install_package()<br>    install.cpp<br>      -&gt;install_package()<br>        -&gt;try_update_binary()</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rk3288源码结构</title>
    <link href="http://joyflyaway.com/2017/12/25/rk3288%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://joyflyaway.com/2017/12/25/rk3288源码结构/</id>
    <published>2017-12-25T09:11:54.000Z</published>
    <updated>2017-12-29T10:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>device/rockchip/rk3288：<br>板级配置<br>  device/rockchip/rk3288/rk3288.mk<br>    PRODUCT_NAME :=<br>    PRODUCT_BRAND :=<br>    PRODUCT_DEVICE :=<br>    PRODUCT_MODEL :=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RK3288编译介绍</title>
    <link href="http://joyflyaway.com/2017/12/25/RK3288%E7%BC%96%E8%AF%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://joyflyaway.com/2017/12/25/RK3288编译介绍/</id>
    <published>2017-12-25T06:32:32.000Z</published>
    <updated>2018-01-17T09:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>[<a href="http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux" target="_blank" rel="external">http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux</a>]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">upgrade_tool:RKTools/linux/Linux_Upgrade_Tool_v1.2/upgrade_tool</div></pre></td></tr></table></figure>
<p>烧写统一固件 update.img<br>sudo upgrade_tool uf update.img</p>
<p>烧写分区镜像：<br>sudo upgrade_tool di -b /path/to/boot.img<br>sudo upgrade_tool di -k /path/to/kernel.img<br>sudo upgrade_tool di -s /path/to/system.img<br>sudo upgrade_tool di -r /path/to/recovery.img<br>sudo upgrade_tool di -m /path/to/misc.img<br>sudo upgrade_tool di resource /path/to/resource.img<br>sudo upgrade_tool di -p paramater   #烧写 parameter<br>sudo upgrade_tool ul bootloader.bin # 烧写 bootloader</p>
<p>如果因 flash 问题导致升级时出错，可以尝试低级格式化、擦除 nand flash：<br>sudo upgrade_tool lf   # 低级格式化<br>sudo upgrade_tool ef   # 擦除</p>
<p>编译内核:<br>make -j${JOBS} -C kernel rockchip_defconfig<br>make -j${JOBS} -C kernel rk3288-${MODEL}.img</p>
<p>编译Android:<br>. build.sh<br>make -j8<br>./mkimage.sh</p>
<p>上一步骤的 ./mkimage.sh 会重新打包 boot.img 和 system.img, 并将其它相关的映像文件拷贝到目录 rockdev/Image-rk3288_box/ 中。以下列出一般固件用到的映像文件：<br>boot.img ：Android 的初始文件映像，负责初始化并加载 system 分区。<br>kernel.img ：内核映像。<br>misc.img ：misc 分区映像，负责启动模式切换和急救模式的参数传递。<br>recovery.img ：急救模式映像。<br>resource.img ：资源映像，内含开机图片和内核的设备树信息。<br>system.img ：Android 的 system 分区映像，ext4 文件系统格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://joyflyaway.com/2017/12/22/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://joyflyaway.com/2017/12/22/git常用命令/</id>
    <published>2017-12-22T09:03:01.000Z</published>
    <updated>2017-12-29T10:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>git checkout -b nativeBranchName remoteBranchPath 切换远程分支到本地<br>git diff –staged 查看未提交的更改</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;git checkout -b nativeBranchName remoteBranchPath 切换远程分支到本地&lt;br&gt;git diff –staged 查看未提交的更改&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Camera调试相关总结</title>
    <link href="http://joyflyaway.com/2017/12/21/camera/"/>
    <id>http://joyflyaway.com/2017/12/21/camera/</id>
    <published>2017-12-21T10:49:21.000Z</published>
    <updated>2018-02-01T10:29:41.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>1.获取设备的自然方向？<br>public int getDeviceDefaultOrientation() {<br>    WindowManager windowManager =  (WindowManager) getSystemService(Context.WINDOW_SERVICE);</p>
<pre><code>Configuration config = getResources().getConfiguration();
int rotation = windowManager.getDefaultDisplay().getRotation();

if ( ((rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180) &amp;&amp;
        config.orientation == Configuration.ORIENTATION_LANDSCAPE)
    || ((rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270) &amp;&amp;    
        config.orientation == Configuration.ORIENTATION_PORTRAIT)) {
  return Configuration.ORIENTATION_LANDSCAPE;
} else {
  return Configuration.ORIENTATION_PORTRAIT;
}
</code></pre><p>}</p>
<p>2.rk3288 摄像头显示改为前置？<br>cam_board.xml 里头有个front 和back配置<br><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=13091&amp;highlight=%C9%E3%CF%F1%CD%B7" target="_blank" rel="external">http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=13091&amp;highlight=%C9%E3%CF%F1%CD%B7</a></p>
<p>3.rk3288 摄像头向左翻转90%显示如何修改?<br><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=12667&amp;highlight=%C9%E3%CF%F1%CD%B7" target="_blank" rel="external">http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=12667&amp;highlight=%C9%E3%CF%F1%CD%B7</a></p>
<p>4.查看相机型号版本<br>getprop | grep sys_graphic</p>
<p>5.camera配置文件path<br>hardware/rk29/camera/Config</p>
<p>6.关键log点<br>CameraHal,</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自定义view</title>
    <link href="http://joyflyaway.com/2017/10/30/%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    <id>http://joyflyaway.com/2017/10/30/自定义view/</id>
    <published>2017-10-30T04:30:35.000Z</published>
    <updated>2017-11-03T09:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>view<br>1.分析view需要哪些属性，在构造方法里获取处理。<br>2.重写测量方法<br>3.重写ondraw方法</p>
<p>viewgroup<br>1.测量<br>2.布局<br>3.事件处理 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;view&lt;br&gt;1.分析view需要哪些属性，在构造方法里获取处理。&lt;br&gt;2.重写测量方法&lt;br&gt;3.重写ondraw方法&lt;/p&gt;
&lt;p&gt;viewgroup&lt;br&gt;1.测量&lt;br&gt;2.布局&lt;br&gt;3.事件处理 &lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
