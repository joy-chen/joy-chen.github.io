<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joy</title>
  <subtitle>abc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joyflyaway.com/"/>
  <updated>2018-01-17T09:16:09.000Z</updated>
  <id>http://joyflyaway.com/</id>
  
  <author>
    <name>Joy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android中系统属性的获取</title>
    <link href="http://joyflyaway.com/2018/01/17/android%E4%B8%AD%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>http://joyflyaway.com/2018/01/17/android中系统属性的获取/</id>
    <published>2018-01-17T09:16:09.000Z</published>
    <updated>2018-01-17T09:16:09.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C本质</title>
    <link href="http://joyflyaway.com/2018/01/17/C%E6%9C%AC%E8%B4%A8/"/>
    <id>http://joyflyaway.com/2018/01/17/C本质/</id>
    <published>2018-01-17T07:01:56.000Z</published>
    <updated>2018-01-17T07:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gradle相关用法</title>
    <link href="http://joyflyaway.com/2018/01/14/gradle%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/"/>
    <id>http://joyflyaway.com/2018/01/14/gradle相关用法/</id>
    <published>2018-01-14T10:46:21.000Z</published>
    <updated>2018-01-14T10:46:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android之Alarm框架</title>
    <link href="http://joyflyaway.com/2018/01/10/Android%E4%B9%8BAlarm%E6%A1%86%E6%9E%B6/"/>
    <id>http://joyflyaway.com/2018/01/10/Android之Alarm框架/</id>
    <published>2018-01-10T07:29:48.000Z</published>
    <updated>2018-01-10T07:29:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android问题定位总结</title>
    <link href="http://joyflyaway.com/2018/01/04/Android%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/"/>
    <id>http://joyflyaway.com/2018/01/04/Android问题定位总结/</id>
    <published>2018-01-04T08:27:05.000Z</published>
    <updated>2018-01-04T08:27:05.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTK_OTA分析</title>
    <link href="http://joyflyaway.com/2017/12/28/MTK-OTA%E5%88%86%E6%9E%90/"/>
    <id>http://joyflyaway.com/2017/12/28/MTK-OTA分析/</id>
    <published>2017-12-28T12:44:24.000Z</published>
    <updated>2017-12-29T10:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<h3 id="SystemUpdate"><a href="#SystemUpdate" class="headerlink" title="SystemUpdate"></a>SystemUpdate</h3><p>MainEntry<br>  onStart()<br>    bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE);<br>      onServiceConnected()<br>        queryPackagesInternal();<br>          mService.queryPackages();<br>            sQueryNewVersionThread.start();<br>              mHttpManager.queryNewVersion();<br>                checkNewVersion()</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;h3 id=&quot;SystemUpdate&quot;&gt;&lt;a href=&quot;#SystemUpdate&quot; class=&quot;headerlink&quot; title=&quot;SystemUpdate&quot;&gt;&lt;/a&gt;SystemUpdate&lt;/h3&gt;&lt;p&gt;MainEntry&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查看调用栈</title>
    <link href="http://joyflyaway.com/2017/12/28/%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <id>http://joyflyaway.com/2017/12/28/查看调用栈/</id>
    <published>2017-12-28T12:18:14.000Z</published>
    <updated>2017-12-29T10:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<ol>
<li>Java中打印调用栈<br>比较简单，利用Throwable，直接log中打印出来：<br>Log.d(TAG, Log.getStackTraceString(new Throwable()));   </li>
</ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;ol&gt;
&lt;li&gt;Java中打印调用栈&lt;br&gt;比较简单，利用Throwable，直接log中打印出来：&lt;br&gt;Log.d(TAG, Log.getStackTraceString(new Throwable()));   &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rk3288_OTA</title>
    <link href="http://joyflyaway.com/2017/12/25/rk3288-OTA/"/>
    <id>http://joyflyaway.com/2017/12/25/rk3288-OTA/</id>
    <published>2017-12-25T11:56:32.000Z</published>
    <updated>2017-12-29T10:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>OTA整个功能代码分布：服务端，recovery，framework层，以及apk共同组成<br>  APK(vendor/rockchip/common/apps/RKUpdateService)<br>  RK只提供apk，没有源码。反编译，apk的主要功能是从服务器下载ota包到本地，<br>  然后写入参数提供给recovery，然后重启进入recovery。</p>
<p>系统升级分为OTA升级和固件包升级<br>OTA方式：<br>1)写如下字段到/cache/recovery/last_flag<br>updating$path=/mnt/internal_sd/update.zip<br>2)写如下字段到/cache/recovery/command<br>–update_package=/mnt/internal_sd/update.zip<br>–locale=en_US<br>3)在adb shell中运行reboot recovery</p>
<h3 id="固件包方式："><a href="#固件包方式：" class="headerlink" title="固件包方式："></a>固件包方式：</h3><p>1)写如下字段到/cache/recovery/last_flag<br>updating$path=/mnt/internal_sd/update.img<br>2)写如下字段到/cache/recovery/command<br>–update_rkimage=/mnt/internal_sd/update.img<br>–locale=en_US<br>3)在adb shell中运行reboot recovery</p>
<h3 id="OTA升级失败排查"><a href="#OTA升级失败排查" class="headerlink" title="OTA升级失败排查:"></a>OTA升级失败排查:</h3><p><a href="http://blog.csdn.net/luzhenrong45/article/details/62042400" target="_blank" rel="external">http://blog.csdn.net/luzhenrong45/article/details/62042400</a></p>
<h3 id="dd命令："><a href="#dd命令：" class="headerlink" title="dd命令："></a>dd命令：</h3><p>  dd备份分区：<br>    df查看各分区使用<br>    mount查看挂载路径<br>    ls /dev/block／platform/xxx/ 查看各分区<br>    cat proc/partitions 查看各分区大小<br>  备份system分区：<br>  dd if=/dev/block/platform/ff0f0000.rksdmmc/by-name/system of=/sdcard/system.img<br>  挂载：mount -t ext4 system.img dest_path<br>  <a href="http://blog.csdn.net/u014134180/article/details/78120143" target="_blank" rel="external">http://blog.csdn.net/u014134180/article/details/78120143</a></p>
<h3 id="recovery相关部分的代码路径"><a href="#recovery相关部分的代码路径" class="headerlink" title="recovery相关部分的代码路径"></a>recovery相关部分的代码路径</h3><p>  ${code_root}/bootable/recovery<br>  ${code_root}/bootable/recovery/recovery.cpp<br>  ${code_root}/bootable/recovery/rkimage.cpp<br>  ${code_root}/frameworks/base/core/java/android/os/RecoverySystem.java</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>The recovery tool communicates with the main system through /cache files.<br>/cache/recovery/command - INPUT - command line for tool, one arg per line<br>/cache/recovery/log - OUTPUT - combined log file from recovery run(s)<br>/cache/recovery/intent - OUTPUT - intent that was passed in</p>
<p>The arguments which may be supplied in the recovery.command file:   </p>
<ul>
<li>–send_intent=anystring - write the text out to recovery.intent</li>
<li>–update_package=path - verify install an OTA package file</li>
<li>–wipe_data - erase user data (and cache), then reboot</li>
<li>–wipe_cache - wipe cache (but not user data), then reboot</li>
<li>–set_encrypted_filesystem=on|off - enables / diasables encrypted fs</li>
<li>–just_exit - do nothing; exit and reboot<br>Arguments may also be supplied in the bootloader control block (BCB).</li>
</ul>
<p>After completing, we remove /cache/recovery/command and reboot.</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>app执行安装/重置/清楚缓存操作调用代码文件<br>  frameworks/base/core/java/android/os/RecoverySystem.java<br>    installPackage<br>    rebootWipeUserData<br>    rebootWipeCache</p>
<p>上面的所有操作都是往/cache/recovery/command文件中写入不同的命令，在进入recovery后（recovery.cpp）对command的关键字进行判断，执行相应的操作</p>
<p>recovery.cpp<br>  -main()<br>   -&gt;install_package()<br>    install.cpp<br>      -&gt;install_package()<br>        -&gt;try_update_binary()</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rk3288源码结构</title>
    <link href="http://joyflyaway.com/2017/12/25/rk3288%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://joyflyaway.com/2017/12/25/rk3288源码结构/</id>
    <published>2017-12-25T09:11:54.000Z</published>
    <updated>2017-12-29T10:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>device/rockchip/rk3288：<br>板级配置<br>  device/rockchip/rk3288/rk3288.mk<br>    PRODUCT_NAME :=<br>    PRODUCT_BRAND :=<br>    PRODUCT_DEVICE :=<br>    PRODUCT_MODEL :=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RK3288编译介绍</title>
    <link href="http://joyflyaway.com/2017/12/25/RK3288%E7%BC%96%E8%AF%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://joyflyaway.com/2017/12/25/RK3288编译介绍/</id>
    <published>2017-12-25T06:32:32.000Z</published>
    <updated>2017-12-29T10:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p><a href="http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux" target="_blank" rel="external">http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">upgrade_tool:RKTools/linux/Linux_Upgrade_Tool_v1.2/upgrade_tool</div></pre></td></tr></table></figure>
<p>烧写统一固件 update.img<br>sudo upgrade_tool uf update.img</p>
<p>烧写分区镜像：<br>sudo upgrade_tool di -b /path/to/boot.img<br>sudo upgrade_tool di -k /path/to/kernel.img<br>sudo upgrade_tool di -s /path/to/system.img<br>sudo upgrade_tool di -r /path/to/recovery.img<br>sudo upgrade_tool di -m /path/to/misc.img<br>sudo upgrade_tool di resource /path/to/resource.img<br>sudo upgrade_tool di -p paramater   #烧写 parameter<br>sudo upgrade_tool ul bootloader.bin # 烧写 bootloader</p>
<p>如果因 flash 问题导致升级时出错，可以尝试低级格式化、擦除 nand flash：<br>sudo upgrade_tool lf   # 低级格式化<br>sudo upgrade_tool ef   # 擦除</p>
<p>编译内核:<br>make -j${JOBS} -C kernel rockchip_defconfig<br>make -j${JOBS} -C kernel rk3288-${MODEL}.img</p>
<p>编译Android:<br>. build.sh<br>make -j8<br>./mkimage.sh</p>
<p>上一步骤的 ./mkimage.sh 会重新打包 boot.img 和 system.img, 并将其它相关的映像文件拷贝到目录 rockdev/Image-rk3288_box/ 中。以下列出一般固件用到的映像文件：<br>boot.img ：Android 的初始文件映像，负责初始化并加载 system 分区。<br>kernel.img ：内核映像。<br>misc.img ：misc 分区映像，负责启动模式切换和急救模式的参数传递。<br>recovery.img ：急救模式映像。<br>resource.img ：资源映像，内含开机图片和内核的设备树信息。<br>system.img ：Android 的 system 分区映像，ext4 文件系统格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.t-firefly.com/index.php/Firefly-RK3288/Flash_image#Linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wik
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://joyflyaway.com/2017/12/22/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://joyflyaway.com/2017/12/22/git常用命令/</id>
    <published>2017-12-22T09:03:01.000Z</published>
    <updated>2017-12-29T10:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>git checkout -b nativeBranchName remoteBranchPath 切换远程分支到本地<br>git diff –staged 查看未提交的更改</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;git checkout -b nativeBranchName remoteBranchPath 切换远程分支到本地&lt;br&gt;git diff –staged 查看未提交的更改&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Camera调试相关总结</title>
    <link href="http://joyflyaway.com/2017/12/21/camera/"/>
    <id>http://joyflyaway.com/2017/12/21/camera/</id>
    <published>2017-12-21T10:49:21.000Z</published>
    <updated>2017-12-29T10:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<p>1.获取设备的自然方向？<br>public int getDeviceDefaultOrientation() {<br>    WindowManager windowManager =  (WindowManager) getSystemService(Context.WINDOW_SERVICE);</p>
<pre><code>Configuration config = getResources().getConfiguration();
int rotation = windowManager.getDefaultDisplay().getRotation();

if ( ((rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180) &amp;&amp;
        config.orientation == Configuration.ORIENTATION_LANDSCAPE)
    || ((rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270) &amp;&amp;    
        config.orientation == Configuration.ORIENTATION_PORTRAIT)) {
  return Configuration.ORIENTATION_LANDSCAPE;
} else {
  return Configuration.ORIENTATION_PORTRAIT;
}
</code></pre><p>}</p>
<p>2.rk3288 摄像头显示改为前置？<br>cam_board.xml 里头有个front 和back配置<br><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=13091&amp;highlight=%C9%E3%CF%F1%CD%B7" target="_blank" rel="external">http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=13091&amp;highlight=%C9%E3%CF%F1%CD%B7</a></p>
<p>3.rk3288 摄像头向左翻转90%显示如何修改?<br><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=12667&amp;highlight=%C9%E3%CF%F1%CD%B7" target="_blank" rel="external">http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=12667&amp;highlight=%C9%E3%CF%F1%CD%B7</a></p>
<p>4.查看相机型号版本<br>getprop | grep sys_graphic</p>
<p>5.camera配置文件path<br>hardware/rk29/camera/Config</p>
<p>6.关键log点<br>CameraHal,</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- excerpt --&gt;
&lt;p&gt;1.获取设备的自然方向？&lt;br&gt;public int getDeviceDefaultOrientation() {&lt;br&gt;    WindowManager windowManager =  (WindowManager) getSyst
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自定义view</title>
    <link href="http://joyflyaway.com/2017/10/30/%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    <id>http://joyflyaway.com/2017/10/30/自定义view/</id>
    <published>2017-10-30T04:30:35.000Z</published>
    <updated>2017-11-03T09:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>view<br>1.分析view需要哪些属性，在构造方法里获取处理。<br>2.重写测量方法<br>3.重写ondraw方法</p>
<p>viewgroup<br>1.测量<br>2.布局<br>3.事件处理 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;view&lt;br&gt;1.分析view需要哪些属性，在构造方法里获取处理。&lt;br&gt;2.重写测量方法&lt;br&gt;3.重写ondraw方法&lt;/p&gt;
&lt;p&gt;viewgroup&lt;br&gt;1.测量&lt;br&gt;2.布局&lt;br&gt;3.事件处理 &lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>睡眠后按键无法唤醒的问题，如何看唤醒过程的log来定位问题</title>
    <link href="http://joyflyaway.com/2017/04/26/%E4%BA%AE%E5%B1%8F%E8%BF%87%E7%A8%8B/"/>
    <id>http://joyflyaway.com/2017/04/26/亮屏过程/</id>
    <published>2017-04-26T08:32:40.000Z</published>
    <updated>2017-04-27T05:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>【使用说明】<br>(1)  以下是列出的整个按键唤醒的log关键点，每条都有粗体字说明其含义以及该注意的关键字；<br>(2)  红色的是kernel log，其他都是main log；<br>(3)  一条一条依次检查，直到如果发现某条log找不到，那问题就出在这个地方；<br>(4)  仅限于JB2之后的Android版本，JB2之前流程相对比较简单；    </p>
<p>kernel-Check Point【1】：按键中断<br> <5>[   78.721504] 1)[Power/PMIC] [pwrkey_int_handler] Press pwrkey</5></p>
<p>Check Point【2】：上层收到按键事件<br>01-09 03:37:40.102   513   561 D WindowManager: interceptKeyTq keycode=26</p>
<p>Check Point【3】：PMS的wakeUp被调用<br>01-09 03:37:40.171   513   531 D PowerManager_performance: wakeUpNoUpdateLocked: eventTime=78826</p>
<p>Check Point【4】：发出MSG_BROADCAST<br>01-09 03:37:40.171   513   531 D PowerManagerNotifier: onWakeUpStarted</p>
<p>Check Point【5】：发出第一个MSG_UPDATE_POWER_STATE<br>01-09 03:37:40.174   513   531 D PowerManagerDisplayController: sendMessage</p>
<p>Check Point【6】：收到并处理MSG_BROADCAST，并且状态是从2变到1<br>01-09 03:37:40.194   513   530 D PowerManagerNotifier: sendNextBroadcast, mBroadcastedPowerState=2, mActualPowerState=1  </p>
<p>Check Point【7】：开始绘制keyguard的流程，发出NOTIFY_SCREEN_ON，等windowToken<br>01-09 03:37:40.217   513   530 D KeyguardViewMediator: notifyScreenOnLocked</p>
<p>Check Point【8】：收到并处理NOTIFY_SCREEN_ON<br>01-09 03:37:40.224   513   531 D KeyguardViewMediator: handleNotifyScreenOn</p>
<p>Check Point【9】：完成绘制keyguard，拿到windowToken<br>01-09 03:37:40.370   513   531 I WindowManager: Lock screen displayed</p>
<p>Check Point【10】：调用回调函数mSceenOnListener，解除Screen on Blocker，mNestCount必须是0<br>01-09 03:37:40.371   513   531 D PowerManagerService: Screen on unblocked: mNestCount=0  </p>
<p>Check Point【11】：处理第一个MSG_UPDATE_POWER_STATE，这里会第一次scheduleScreenUpdate<br>01-09 03:37:40.254   513   546 D PowerManagerDisplayState: setScreenOn: on=true</p>
<p>Check Point【12】：第一次执行scheduleScreenUpdate，进入setState<br>01-09 03:37:40.330   513   546 D PowerManagerDisplayState: Requesting new screen state: on=true, backlight=0</p>
<p>Check Point【13】：发出第二个MSG_UPDATE_POWER_STATE<br>01-09 03:37:40.334   513   546 D PowerManagerDisplayController: sendMessage.  </p>
<p>Check Point【14】：第一次执行mTask， on跟onChanged 必须都是true<br>01-09 03:37:40.334   513   546 D PowerManagerDisplayState: mTask: on = true, onChanged = true, backlightChanged = false</p>
<p>kernel-Check Point【15】：进入unblankAllDisplays，开始底层late_resume流程<br>01-09 03:37:40.334   513   546 D PowerManagerService: unblankAllDisplays in …</p>
<p>Check Point【16】：底层late_resume流程结束<br>01-09 03:37:40.673   513   546 D PowerManagerService-JNI: Excessive delay in autosuspend_disable() while turning screen on: 337ms  </p>
<p>Check Point【17】：unblankAllDisplays流程结束<br>01-09 03:37:40.701   513   546 D PowerManager_performance: unblankAllDisplays out …  </p>
<p>Check Point【18】：处理第二个MSG_UPDATE_POWER_STATE<br>01-09 03:37:40.702   513   546 D PowerManagerDisplayController: setScreenOn true  </p>
<p>Check Point【19】：前面的Screen On Blocker被解除，才会调用这里<br>01-09 03:37:40.702   513   546 D PowerManagerDisplayController: Unblocked screen on after 447 ms  </p>
<p>Check Point【20】：设置ElectronBeamLevel，值不为0才能点亮背光，并且这里会第二次scheduleScreenUpdate<br>01-09 03:37:40.704   513   546 D PowerManagerDisplayState: setElectronBeamLevel: level=1.0  </p>
<p>Check Point【21】：第二次执行scheduleScreenUpdate，进入setState，注意backlight值不为0<br>01-09 03:37:40.718   513   546 D PowerManagerDisplayState: Requesting new screen state: on=true, backlight=86,  </p>
<p>Check Point【22】：第二次执行mTask，backlightChanged必须是true<br>01-09 03:37:40.721   513   546 D PowerManagerDisplayState: mTask: on = true, onChanged = false, backlightChanged = true</p>
<p>Check Point【23】：调用light service，写backlight节点，light 0表示backlight<br>01-09 03:37:40.721   513   546 D LightsService: setLight_native: light=0, colorARGB=0xff565656, flashMode=0,</p>
<p>kernel-Check Point【24】：驱动底层背光生效</p>
<p><4>[   79.447236] (1)[546:PowerManagerSer]mt65xx_leds_set_cust: set brightness, name:lcd-backlight, mode:6, level:86</4></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>待机时，怎么看AP每次wake up起来的时长</title>
    <link href="http://joyflyaway.com/2017/04/26/%E5%94%A4%E9%86%92%E6%97%B6%E9%95%BF/"/>
    <id>http://joyflyaway.com/2017/04/26/唤醒时长/</id>
    <published>2017-04-26T02:51:20.000Z</published>
    <updated>2017-04-26T08:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION]"></a>DESCRIPTION]</h3><p>分析待机平均电流高的问题时，经常需要知道每次wake up起来的时间点，以及唤醒的时长，以此找到一些异常的唤醒</p>
<h3 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="[SOLUTION]"></a>[SOLUTION]</h3><p>MT6572<br>（1）查找kernel log中的“Wakeup Succefully”信息<br>（2）“往下”查找离这条log最近的带“UTC”的log，UTC log中显示的时间就是唤醒的时间（跟main log的时间一致）<br>（3）往下查找离这条log最近的“[SPM] Kernel Suspend with”信息，跟“Wakeup Succefully”的时间戳相减就是wake up的时长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg：</div><div class="line">&lt;4&gt;[ 2497.698724]-(0)[789:kworker/u:3][PCM WAKEUP NORMAL]CPU WAKE UP BY: EINT :0x10000</div><div class="line">&lt;6&gt;[ 2497.901281] (0)[789:kworker/u:3]PM: suspend exit 2013-05-27 00:40:53.186864384 UTC</div><div class="line">&lt;2&gt;[ 2539.341088]-(0)[789:kworker/u:3][SPM] Kernel Suspend with cpu_pdn=1, infra_pdn=1</div><div class="line">唤醒时间点：00：40：53</div><div class="line">唤醒时长：2539-2497 = 42s</div></pre></td></tr></table></figure></p>
<p>其他平台<br>（1）查找kernel log中的“wake up by XXX”信息<br>（2）“往下”查找离这条log最近的带“UTC”的log，UTC log中显示的时间加8小时就是真实的唤醒时间（跟main log的时间一致）<br>（3）往下查找离这条log最近的“wakesrc”信息，跟“wake up by XXX”的时间戳相减就是wake up的时长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">eg：</div><div class="line">&lt;5&gt;[  621.286161] (0)[53:kworker/u:2][Power/Sleep] wake up by EINT (0x20)(0x4)(41695)</div><div class="line">&lt;5&gt;[  621.626419] (0)[310:WindowManagerPo][request_suspend_state]: wakeup (3-&gt;0) at 612863283411 (2013-05-24 07:50:14.331687541 UTC)</div><div class="line">&lt;5&gt;[  665.287105] (0)[1218:kworker/u:3][Power/Sleep] sec = 300, wakesrc = 0x1ec</div><div class="line"></div><div class="line">唤醒时间点：07(+8)：50：14 = 15：50：14</div><div class="line">唤醒时长：665-621 = 44s</div></pre></td></tr></table></figure></p>
<h2 id="待机电流问题，如何查找wakelock"><a href="#待机电流问题，如何查找wakelock" class="headerlink" title="待机电流问题，如何查找wakelock"></a>待机电流问题，如何查找wakelock</h2><p>【step1-找kernel层的wakelock】</p>
<p>（1）先搜索从wake进入sleep的过程中打印出来的当前处于活动状态的wakelock<br>关键字“print_active_wakeup_sources”，类似于下面这样的log：</p>
<p>  [print_active_wakeup_sources]: activity: PowerManagerService<br>  [print_active_wakeup_sources]: activity: syspb_149<br>  [print_active_wakeup_sources]: activity: EINT wakelock</p>
<p>如果没有这样的log，可以把所有申请wakelock的代码搜出来，关键字“ws activate-&gt;”</p>
<p>（2）然后往下搜索有没有这些wakelock释放的位置<br>关键字“ws deactivate-&gt;”类似如下log：</p>
<pre><code>ws deactivate-&gt;  PowerManagerService
ws deactivate-&gt;  EINT wakelock
</code></pre><p>（3）那会出项两种情况<br>a. 根本没有找到释放某个wakelock的log<br>那就可以确实是这个wakelock导致（比如上面的syspb_149）<br>b. 有找到释放的log，但是中间间隔时间很长<br>这个就要看时间戳了，所以把申请释放的时间戳相减就是真实的wakelock锁住的时长</p>
<p>（4）找到wakelock后，要做的就是去检查wakelock的使用者<br>          a. 如果发现出问题的不是PowerManagerService的wakelock，那么就直接找对应的驱动代码就行了<br>b. 如果是，就要继续看main log</p>
<p>【step2-找user层的wakelock】</p>
<p>（1）找到所有上层的wakelock申请的log<br>关键字“acquireWakeLockInternal”，会搜出来很多，类似下面的log：</p>
<p>acquireWakeLockInternal: lock=1131418552, flags=0x1, tag=”GSM”, ws=null, uid=1001, pid=696<br>acquireWakeLockInternal: lock=1131101696, flags=0x1, tag=”RILJ”, ws=null, uid=1001, pid=696<br>acquireWakeLockInternal: lock=1130767880, flags=0x20, tag=”PhoneGlobals”, ws=null, uid=1001, pid=696</p>
<p>但是不要担心，一般像 RILJ / ActivityManager / AlarmManager申请释放很频繁的就不用理会；flag的bit0不为1的也不用理会（bit0标识锁住底层不进sleep；但是有个例外，就是Psensor对应的wakelock，flags为0x20，在早期JB版本也会锁住底层）</p>
<p>（2）找到这些wakelock释放的log<br>关键字“releaseWakeLockInternal”，但是你可能只能看到下面这样的log：</p>
<p>releaseWakeLockInternal: lock=1131101696, flags=0x0<br>releaseWakeLockInternal: lock=1131418552, flags=0x0<br>releaseWakeLockInternal: lock=1130767880, flags=0x1(这个flag为1表示waitForNegativeProximity)</p>
<p>跟acquire的log的对应关系就是看lock=后面的整数值，就知道wakelock是在哪个时间点释放的了，两个时间戳相减就是锁住的时间，抓住wakelock时间不长的就可以忽略，找到那个长时间锁住的wakelock就是系统无法休眠的罪魁祸首</p>
<p>（3）找到wakelock后，就根据“tag”的字符串去找对应的代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ANR分析</title>
    <link href="http://joyflyaway.com/2017/04/21/ANR%E5%88%86%E6%9E%90/"/>
    <id>http://joyflyaway.com/2017/04/21/ANR分析/</id>
    <published>2017-04-21T08:50:37.000Z</published>
    <updated>2017-12-29T10:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>ANR分为一下几类：</p>
<ul>
<li>广播ANR</li>
<li>Service ANR</li>
<li>ContentProvider ANR</li>
<li>Input ANR</li>
<li>WatchDog</li>
</ul>
<p>产生ANR原因：   </p>
<ul>
<li>耗时操作</li>
<li>自身服务阻塞</li>
<li>系统阻塞</li>
<li>内存紧张</li>
<li>CPU资源抢占</li>
</ul>
<p>对于这些ANR，给大家的推荐一下大致分析思路和相关日志，通常发生ANR时，首先去查找对应Trace日志，看看主线程是否在处理该广播或被阻塞，如果发现上述现象，那么恭喜你，已经很接近答案了。但如果发现堆栈完全处于空闲状态，那么很不幸，就需要扩大参考面了，需要结合log日志进行分析，日志包括logcat, kernel日志，cpuinfo以及meminfo等，参考顺序从前向后。<br>1、分析logcat思路：首先在日志中搜索（“anr in”，“low_memory”, “slow_operation”）等关键字，通过该类关键字主要是查看系统Cpu负载，如果是发现应用进程CPU明显过高，那么很有可能是该进程抢占CPU过多导致，系统调度不及时,误认为应用发生了超时行为。<br>2、分析kernel思路：在此类日志中直接搜索lowmemorykiller, 如果存在则查看发生时间和ANR时间是否大致对应，相差无几的话，可以从该日志中看到操作系统层面当前内存情况，Free Memory说明的是空闲物理内存，File Free说明的则是文件Cache，也就是应用或系统从硬盘读取文件，使用结束后，kernel并没有这正释放这类内存，加以缓存，目的是为了下次读写过程加快速度。当然，发现Free和Other整体数值都偏低时，Kernel会进行一定程度的内存交换，导致整个系统卡顿。同时这类现象也会体现在log日志“slow_operation”中，即系统进程的调度也会收到影响。<br>3、分析cpuinfo思路：这类日志一目了然，可以清晰的看到哪类进程CPU偏高，如果存在明显偏高进程，那么ANR和此进程抢占CPU有一定关系。当然，如发现Kswapd，emmc进程在top中，则说明遇到系统内存压力或文件IO开销。<br>4、分析meminfo思路：分析该类日志，主要是看哪类应用或系统占用内存偏高，如果应用内存占用比较正常，系统也没有发生过度内存使用，那么则说明系统中缓存了大量进程，并没有及时释放导致系统整体内存偏低。   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App启动过程</title>
    <link href="http://joyflyaway.com/2017/04/19/App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://joyflyaway.com/2017/04/19/App启动过程/</id>
    <published>2017-04-19T08:02:01.000Z</published>
    <updated>2017-04-21T08:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h4 id="从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈"><a href="#从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈" class="headerlink" title="从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈"></a>从桌面到Activity的调用堆栈，因为这部分较简单，我们直接列出调用堆栈</h4><p>-&gt;com.android.launcher3.Launcher#onClick<br>&emsp;-&gt;Launcher#onClickAppShortcut<br>&emsp;&emsp;-&gt;Launcher#startAppShortcutOrInfoActivity<br>&emsp;&emsp;&emsp;-&gt;Launcher#startActivitySafely<br>&emsp;&emsp;&emsp;&emsp;-&gt;Launcher#startActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;Activity#startActivity</p>
<h4 id="从Activity-startActivity，到启动进程和launch-activity的调用堆栈"><a href="#从Activity-startActivity，到启动进程和launch-activity的调用堆栈" class="headerlink" title="从Activity#startActivity，到启动进程和launch activity的调用堆栈"></a>从Activity#startActivity，到启动进程和launch activity的调用堆栈</h4><p><code>1.调用堆栈</code><br><code>1-1.准备新的activity</code><br>-&gt;Activity#startActivity<br>&emsp;-&gt;Activity#startActivityForResult  //此时mInstrumentation变量为源activity的，即launcher3<br>&emsp;&emsp;-&gt;Instrumentation#execStartActivity<br>&emsp;&emsp;&emsp;-&gt;ActivityManagerService#startActivity<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#startActivityAsUser<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startActivityMayWait<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startActivityUncheckedLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#startActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#resumeTopActivitiesLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityInnerLocked  </p>
<p><code>1-2.暂停旧的activity</code><br>&emsp;-&gt;ActivityStackSupervisor#pauseBackStacks<br>&emsp;&emsp;-&gt;ActivityStack#startPausingLocked<br>&emsp;&emsp;&emsp;-&gt;ActivityThread#schedulePauseActivity<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#handlePauseActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#activityPaused<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#activityPausedLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStack#completePauseLocked   </p>
<p><code>1-3.启动进程</code><br>&emsp;-&gt;ActivityStackSupervisor#resumeTopActivitiesLocked<br>&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityLocked<br>&emsp;&emsp;&emsp;-&gt;ActivityStack#resumeTopActivityInnerLocked<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#startSpecificActivityLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#startProcessLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;Process#start<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#main<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;从ActivityThread#attach<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#attachApplication<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityManagerService#attachApplicationLocked<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread$ApplicationThread#bindApplication<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#handleBindApplication    </p>
<p><code>1-4.启动新的activity，走ActivityStackSupervisor#attachApplicationLocked分支</code><br>&emsp;-&gt;ActivityManagerService#attachApplicationLocked<br>&emsp;&emsp;-&gt;ActivityStackSupervisor#attachApplicationLocked<br>&emsp;&emsp;&emsp;-&gt;ActivityStackSupervisor#realStartActivityLocked<br>&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread$ApplicationThread#scheduleLaunchActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#handleLaunchActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;ActivityThread#performLaunchActivity<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;LoadedApk#makeApplication<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-&gt;Activity#attach   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编译问题</title>
    <link href="http://joyflyaway.com/2017/04/19/%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"/>
    <id>http://joyflyaway.com/2017/04/19/编译问题/</id>
    <published>2017-04-19T02:15:43.000Z</published>
    <updated>2017-04-21T08:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h3 id="编译android-7-0-出现Try-increasing-heap-size-with-java-option-‘-Xmx‘错误解决方案"><a href="#编译android-7-0-出现Try-increasing-heap-size-with-java-option-‘-Xmx‘错误解决方案" class="headerlink" title="编译android 7.0 出现Try increasing heap size with java option ‘-Xmx‘错误解决方案"></a>编译android 7.0 出现Try increasing heap size with java option ‘-Xmx<size>‘错误解决方案</size></h3><p>出现这个错误是由于电脑内存不足，在命令行分别执行以下三条语句，然后继续编译<br>export JACK_SERVER_VM_ARGUMENTS=”-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g”<br>./prebuilts/sdk/tools/jack-admin kill-server<br>./prebuilts/sdk/tools/jack-admin start-server   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MAT工具</title>
    <link href="http://joyflyaway.com/2017/03/30/MAT%E5%B7%A5%E5%85%B7/"/>
    <id>http://joyflyaway.com/2017/03/30/MAT工具/</id>
    <published>2017-03-30T11:50:15.000Z</published>
    <updated>2017-04-19T02:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Shallow-Heap-Size"><a href="#Shallow-Heap-Size" class="headerlink" title="Shallow Heap Size:"></a>Shallow Heap Size:</h3><p>指对象自身所占用的内存大小，不包含其引用的对象所占的内存大小。<br>1、数组类型<br>数组元素对象所占内存的大小总和。<br>2、非数组类型<br>对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。   </p>
<h3 id="Retained-Heap-Size"><a href="#Retained-Heap-Size" class="headerlink" title="Retained Heap Size:"></a>Retained Heap Size:</h3><p>前对象大小+当前对象可直接或间接引用到的对象的大小总和。<br>(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。<br>不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage。</p>
<h3 id="Java的内存泄露的特点"><a href="#Java的内存泄露的特点" class="headerlink" title="Java的内存泄露的特点"></a>Java的内存泄露的特点</h3><ul>
<li>Java中的内存泄露主要特征：可达，无用</li>
<li>无用指的是创建了但是不再使用之后没有释放</li>
<li>能重用但是却创建了新的对象进行处理</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效代码</title>
    <link href="http://joyflyaway.com/2017/03/30/%E9%AB%98%E6%95%88%E4%BB%A3%E7%A0%81/"/>
    <id>http://joyflyaway.com/2017/03/30/高效代码/</id>
    <published>2017-03-30T03:17:02.000Z</published>
    <updated>2017-04-19T02:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<p>通常来说，高效的代码需要满足下面两个规则：</p>
<ul>
<li>不要做冗余的动作</li>
<li>如果能避免，尽量不要分配内存</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author JOY.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
